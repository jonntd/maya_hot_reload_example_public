{
    "docs": [
        {
            "location": "/", 
            "text": "Runtime Compiled C++ in Maya\n\n\nAbout\n\n\nThis is a tutorial on how to setup a workflow for writing C++ code in Maya that\nis \nhot-loadable\n; which is to say, you can compile your code and watch your\nchanges take effect \ninstantly, on-the-fly\n, without having to unload/reload your\nplugin, or worse, restart Maya.\n\n\nAll the source code for this example node is available\n\nhere\n.\n\n\nWhy should I care?\n\n\nSeveral reasons:\n\n\n\n\n\n\nBeing able to iterate quickly is a receipe for success\n. This applies in many\n  disciplines, but especially so in programming; \nthe faster you see results, the\n  faster you can make decisions about those results and continue with your\n  work.\n The less time you spend waiting between rebuilds/IDE lag/getting coffee,\n  the more time you spend \nmaking decisions about your data\n.\n  The more decisions you make, the more work you're able to get done.\n\n\n\n\n\n\nPeople dislike C/C++ because it is perceived to be \"difficult\" or \"slow to\n  write in\".\n (In fact, I used to be like this as well when I first started out\n  learning the language.) The alternative (which usually means using a scripting\n  language like Python/MEL/Lua, or using an intermediate runtime solution\n  through LLVM IR like \nFabric Engine\n/Maya\n  Bifrost) is actually \nslower\n to iterate in when it comes to production use cases.\n  Nevertheless, it must be recognized that when it comes to writing Maya\n  plug-ins, it is, in truth, a very involved process for even an experienced C++\n  programmer to even get a plug-in compiled and working for the first\n  time. \nThis workflow aims to make that approach faster than any scripting\n  language-based workflow can achieve.\n\n\n\n\n\n\nYou can debug state-based problems much more easily.\n For example, let's\n  say you were writing a deformer, and had a bug that only occurred when the\n  input mesh was deformed a certain way, on a specific frame, and perhaps only 1\n  out of 5 times under the right circumstances. Worse, it's a simulation, so\n  your output is not always idempotent (thus making it very difficult to unit\n  test). Conventionally, you would need to unload/reload the plugin, re-setup\n  the mesh in the specific manner that you suspect would trigger the issue and\n  repeat this process ad-infinitum while you maybe had a debugger attached in\n  the hope that you could catch the issue. With the ability to hotload your code\n  on-the-fly, you can \nsee your decision changes immediately as you make changes\n  to the code in context\n. This makes it incredibly powerful as a debugging\n  tool, since you can now easily narrow down the cause of bugs by changing the\n  code, re-compiling, and watching your deformer \nupdate instantly\n, all without\n  having to re-setup the context (mesh inputs, playback to current frame, etc.).\n\n\n\n\n\n\nProgramming becomes fun again!\n Let's face it; the process for getting a\n  Maya plugin working can be infinitely more draining than the process of\n  actually writing the code itself; even without taking the Maya API itself into\n  account with its ideas forced unto you, the build/linking process is incredibly\n  convoluted, the dependencies number in the dozens, and the worst part is that\n  all of it almost always has \nnothing\n to do with the actual problem you're\n  trying to solve. If you could reduce the amount of \ncruft\n you have to deal\n  with and focus on the \nbusiness logic\n of the plug-in you're trying to\n  \ncraft\n instead, wouldn't you prefer that?\n\n\n\n\n\n\nWhy not use a scripting language?\n\n\nWith all that being said, a very common solution to the problems above already\nexists, and has for quite some time now: scripting languages. Whether it be\nwriting your code in Python/Lua/C#/MEL whatever, what usually happens is that\nthese languages have a \ninterpreter\n embedded in the host application, and\nallow you to write some code, perform Just-In-Time (JIT) compilation on it to\nmachine code to execute directly.\n\n\n\n\nWhat about LLVM Intermediate Runtime (IR)?\n\n\nThere are solutions that go further by compiling your source code to an\n\nintermediate runtime\n\n(the most popular method seems to be using\nthe \nLLVM toolchain\n to do so) before allowing the LLVM\nbackend to translate it to actual CPU instructions, allowing\nfor greater optimization by the compiler, thus resulting in improved performance\nover having an embedded interpreter .\n\n\nMarco Giordano\n has a great\nsimplified example of this running using his own custom compiler for his\nimplementation of his C-like scripting language inside Maya. \nFabric Engine\n, as\nalready mentioned, was taking advantage of this method as well, and the new\n\nBifrost\n framework in Maya will also be utilizing this approach.\n\n\n\n\nHowever, these solutions suffer from the same issue that all scripting languages\nsuffer from: they only give you what they've specifically exposed; you rarely\nhave full control over the actual memory you're dealing with, and in the case of\na Maya C++ plugin, you don't have full access to the entire Maya API (even if\nyou're using OpenMaya.) As we are \nprogrammers\n, our primary job is first and\nforemost to \ndeal with memory\n. Therefore, the existing solutions are what I\nwould consider \nincomplete\n, and thus we will not discuss them throughout this\ndocument.\n\n\nThat being said, there is a time and place for such scripting languages and\ntechniques, and by no means should you view their usage as undesirable.\n\n\nHow is this going to work?\n\n\nBasically, the idea is that we will have a single \n.cpp\n file, \nlogic.cpp\n,\nthat will act as our \nentry-point\n \"script\" file of sorts; we'll be able to\ncontinuously edit that file, re-build our plugin, and see our deformer update in\nthe Maya viewport.\n\n\nWe'll have two libraries, one that will be known as the \nhost library\n, and\nthe other as the \nclient library\n. The client library will be the one that is\ncontinuously re-compiled and hot-loaded, while the host library will remain\n(mostly) immutable. Of course, we should be able to add additional \n.cpp\n and\n\n.h\n files with their own corresponding logic as well and hot-load them as\nnecessary, but everything will go through that original \nlogic.cpp\n file\nfirst; that's why it's referred to as the \nentry-point\n for our \nbusiness\nlogic\n.\n\n\nRequirements\n\n\nWhat you will need\n\n\n\n\nMaya 2016 or higher\n. (Really, any modern version of Maya will do.)\n\n\nA \nC/C++ development environment\n set up and ready to go. (If you want to see\n  what my Emacs setup looks like, it's\n  available \nhere\n.)\n\n\nAccess to the \nLinux manpages\n/\nWindows MSDN documentation\n.\n\n\nSpare time and an open mind.\n\n\n\n\nThis tutorial will provide instructions for the main supported platforms that\nMaya runs on, namely Windows, Linux and OSX. However, for fairly obvious reasons,\nthe tutorial will come from a \nWindows-first approach\n. Whenever platform-specific\ninformation is appropriate, it will appear in the following form:\n\n\n\n\nCrossing the platforms\n\n\nPlatform-specific information goes here.\n\n\n\n\nWhat you should know\n\n\n\n\n\n\nBasic knowledge of C/C++\n. I will focus on including only the code that is\n  important; I expect you to be able to understand how to fill in the rest as\n  needed. At the very least, you should be able to compile a Maya plug-in and\n  run it using whatever toolchain you're familar with.\n\n\n\n\n\n\nKnowledge of how the dependency graph works in Maya and how dirty propagation works.\n\n\n\n\n\n\nBasic knowledge of how Maya plugins work and how to write/build them\n. There is\n  a sample \nCMakeLists.txt\n build script provided for reference if you need a\n  refresher on that. You can use whatever build system you want; I just use CMake\n  for convenience's sake.\n\n\n\n\n\n\nIn the next section, we'll go over a high-level overview of what this tutorial is\nattempting to cover and some basic fundamentals of how memory works.", 
            "title": "About"
        }, 
        {
            "location": "/#runtime-compiled-c-in-maya", 
            "text": "", 
            "title": "Runtime Compiled C++ in Maya"
        }, 
        {
            "location": "/#about", 
            "text": "This is a tutorial on how to setup a workflow for writing C++ code in Maya that\nis  hot-loadable ; which is to say, you can compile your code and watch your\nchanges take effect  instantly, on-the-fly , without having to unload/reload your\nplugin, or worse, restart Maya.  All the source code for this example node is available here .", 
            "title": "About"
        }, 
        {
            "location": "/#why-should-i-care", 
            "text": "Several reasons:    Being able to iterate quickly is a receipe for success . This applies in many\n  disciplines, but especially so in programming;  the faster you see results, the\n  faster you can make decisions about those results and continue with your\n  work.  The less time you spend waiting between rebuilds/IDE lag/getting coffee,\n  the more time you spend  making decisions about your data .\n  The more decisions you make, the more work you're able to get done.    People dislike C/C++ because it is perceived to be \"difficult\" or \"slow to\n  write in\".  (In fact, I used to be like this as well when I first started out\n  learning the language.) The alternative (which usually means using a scripting\n  language like Python/MEL/Lua, or using an intermediate runtime solution\n  through LLVM IR like  Fabric Engine /Maya\n  Bifrost) is actually  slower  to iterate in when it comes to production use cases.\n  Nevertheless, it must be recognized that when it comes to writing Maya\n  plug-ins, it is, in truth, a very involved process for even an experienced C++\n  programmer to even get a plug-in compiled and working for the first\n  time.  This workflow aims to make that approach faster than any scripting\n  language-based workflow can achieve.    You can debug state-based problems much more easily.  For example, let's\n  say you were writing a deformer, and had a bug that only occurred when the\n  input mesh was deformed a certain way, on a specific frame, and perhaps only 1\n  out of 5 times under the right circumstances. Worse, it's a simulation, so\n  your output is not always idempotent (thus making it very difficult to unit\n  test). Conventionally, you would need to unload/reload the plugin, re-setup\n  the mesh in the specific manner that you suspect would trigger the issue and\n  repeat this process ad-infinitum while you maybe had a debugger attached in\n  the hope that you could catch the issue. With the ability to hotload your code\n  on-the-fly, you can  see your decision changes immediately as you make changes\n  to the code in context . This makes it incredibly powerful as a debugging\n  tool, since you can now easily narrow down the cause of bugs by changing the\n  code, re-compiling, and watching your deformer  update instantly , all without\n  having to re-setup the context (mesh inputs, playback to current frame, etc.).    Programming becomes fun again!  Let's face it; the process for getting a\n  Maya plugin working can be infinitely more draining than the process of\n  actually writing the code itself; even without taking the Maya API itself into\n  account with its ideas forced unto you, the build/linking process is incredibly\n  convoluted, the dependencies number in the dozens, and the worst part is that\n  all of it almost always has  nothing  to do with the actual problem you're\n  trying to solve. If you could reduce the amount of  cruft  you have to deal\n  with and focus on the  business logic  of the plug-in you're trying to\n   craft  instead, wouldn't you prefer that?", 
            "title": "Why should I care?"
        }, 
        {
            "location": "/#why-not-use-a-scripting-language", 
            "text": "With all that being said, a very common solution to the problems above already\nexists, and has for quite some time now: scripting languages. Whether it be\nwriting your code in Python/Lua/C#/MEL whatever, what usually happens is that\nthese languages have a  interpreter  embedded in the host application, and\nallow you to write some code, perform Just-In-Time (JIT) compilation on it to\nmachine code to execute directly.   What about LLVM Intermediate Runtime (IR)?  There are solutions that go further by compiling your source code to an intermediate runtime \n(the most popular method seems to be using\nthe  LLVM toolchain  to do so) before allowing the LLVM\nbackend to translate it to actual CPU instructions, allowing\nfor greater optimization by the compiler, thus resulting in improved performance\nover having an embedded interpreter .  Marco Giordano  has a great\nsimplified example of this running using his own custom compiler for his\nimplementation of his C-like scripting language inside Maya.  Fabric Engine , as\nalready mentioned, was taking advantage of this method as well, and the new Bifrost  framework in Maya will also be utilizing this approach.   However, these solutions suffer from the same issue that all scripting languages\nsuffer from: they only give you what they've specifically exposed; you rarely\nhave full control over the actual memory you're dealing with, and in the case of\na Maya C++ plugin, you don't have full access to the entire Maya API (even if\nyou're using OpenMaya.) As we are  programmers , our primary job is first and\nforemost to  deal with memory . Therefore, the existing solutions are what I\nwould consider  incomplete , and thus we will not discuss them throughout this\ndocument.  That being said, there is a time and place for such scripting languages and\ntechniques, and by no means should you view their usage as undesirable.", 
            "title": "Why not use a scripting language?"
        }, 
        {
            "location": "/#how-is-this-going-to-work", 
            "text": "Basically, the idea is that we will have a single  .cpp  file,  logic.cpp ,\nthat will act as our  entry-point  \"script\" file of sorts; we'll be able to\ncontinuously edit that file, re-build our plugin, and see our deformer update in\nthe Maya viewport.  We'll have two libraries, one that will be known as the  host library , and\nthe other as the  client library . The client library will be the one that is\ncontinuously re-compiled and hot-loaded, while the host library will remain\n(mostly) immutable. Of course, we should be able to add additional  .cpp  and .h  files with their own corresponding logic as well and hot-load them as\nnecessary, but everything will go through that original  logic.cpp  file\nfirst; that's why it's referred to as the  entry-point  for our  business\nlogic .", 
            "title": "How is this going to work?"
        }, 
        {
            "location": "/#requirements", 
            "text": "", 
            "title": "Requirements"
        }, 
        {
            "location": "/#what-you-will-need", 
            "text": "Maya 2016 or higher . (Really, any modern version of Maya will do.)  A  C/C++ development environment  set up and ready to go. (If you want to see\n  what my Emacs setup looks like, it's\n  available  here .)  Access to the  Linux manpages / Windows MSDN documentation .  Spare time and an open mind.   This tutorial will provide instructions for the main supported platforms that\nMaya runs on, namely Windows, Linux and OSX. However, for fairly obvious reasons,\nthe tutorial will come from a  Windows-first approach . Whenever platform-specific\ninformation is appropriate, it will appear in the following form:   Crossing the platforms  Platform-specific information goes here.", 
            "title": "What you will need"
        }, 
        {
            "location": "/#what-you-should-know", 
            "text": "Basic knowledge of C/C++ . I will focus on including only the code that is\n  important; I expect you to be able to understand how to fill in the rest as\n  needed. At the very least, you should be able to compile a Maya plug-in and\n  run it using whatever toolchain you're familar with.    Knowledge of how the dependency graph works in Maya and how dirty propagation works.    Basic knowledge of how Maya plugins work and how to write/build them . There is\n  a sample  CMakeLists.txt  build script provided for reference if you need a\n  refresher on that. You can use whatever build system you want; I just use CMake\n  for convenience's sake.    In the next section, we'll go over a high-level overview of what this tutorial is\nattempting to cover and some basic fundamentals of how memory works.", 
            "title": "What you should know"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Getting started\n\n\nWhat are we even doing?\n\n\nHere's \nwhat's going down\n. The\nnormal approach for how a custom node in Maya would work would be something like\nthe following (connections that are called once are dashed, and connections that\nare called all the time are solid):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\noverview\n\n\n\n\n\n\nMaya\n\n\n\n\nMaya\n\n\n\n\n\n\nhost\n\n\n\n\n\n\nPlugin DLL/SO\n\n\n\n\ninitializePlugin()\n\n\n\n\nuninitializePlugin()\n\n\n\n\ndeform()\n\n\n\n\n...\n\n\n\n\n\n\nhost:ip\nMaya\n\n\n\n\n\n\nCalled when plugin is loaded\n\n\n\n\n\n\nhost:up\nMaya\n\n\n\n\n\n\nCalled when plugin is unloaded\n\n\n\n\n\n\nhost:d\nMaya\n\n\n\n\n\n\nCalled when node is dirtied\n\n\n\n\n\n\n\n\n\nIt's pretty straightforward; the plugin \nDynamic-link library (Windows/OSX) or\nShared Object (Linux)\n contains all the initialization/uninitialization/deformation\nlogic/whatever necessary for the plugin to function; Maya just loads the entire binary,\ncalls the functions as needed whenever it determines it should, and that's the\nend of the story.\n\n\nWhat we're going to be doing instead is something like the following:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\noverview\n\n\n\n\n\n\nMaya\n\n\n\n\nMaya\n\n\n\n\n\n\nhost\n\n\n\n\n\n\nHost Plugin\n\n\n\n\ninitializePlugin()\n\n\n\n\nuninitializePlugin()\n\n\n\n\ndeform()\n\n\n\n\n\n\nhost:ip\nMaya\n\n\n\n\n\n\nCalled on load\n\n\n\n\n\n\nhost:up\nMaya\n\n\n\n\n\n\nCalled on unload\n\n\n\n\n\n\nhost:d\nMaya\n\n\n\n\n\n\nCalled when dirtied\n\n\n\n\n\n\nclient\n\n\n\n\n\n\nClient Plugin\n\n\n\n\nlogic()\n\n\n\n\n...\n\n\n\n\n\n\nclient:l\nhost:d\n\n\n\n\n\n\nCheck last modified timestamp\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nIf the above didn't make any sense, please take a moment to review\nthe\n\nAutodesk documentation\n\nregarding how Maya plugins and their entry points work.\n\n\n\n\nIn this scenario, the \nlogic()\n function will now contain all the \nbusiness\nlogic\n necessary for the \ndeform()\n function to work; the \ndeform()\n\nfunction itself will become pretty much nothing but a wrapper around Maya's\nmachinery. (For simplicity's sake, I will not be discussing taking the\n\ndeform()\n function out of the host plugin as well in this tutorial, though it\nis certainly possible, and I encourage you to try!)\n\n\nOK, so far it's just a level of abstraction that we've introduced here. What\nhappens when we re-compile the client plugin?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\noverview\n\n\n\n\n\n\nMaya\n\n\n\n\nMaya\n\n\n\n\n\n\nhost\n\n\n\n\n\n\nHost Plugin\n\n\n\n\ninitializePlugin()\n\n\n\n\nuninitializePlugin()\n\n\n\n\ndeform()\n\n\n\n\n\n\nhost:ip\nMaya\n\n\n\n\n\n\nCalled on load\n\n\n\n\n\n\nhost:up\nMaya\n\n\n\n\n\n\nCalled on unload\n\n\n\n\n\n\nhost:d\nMaya\n\n\n\n\n\n\nCalled when dirtied\n\n\n\n\n\n\nclientOld\n\n\n\n\n\n\nClient Plugin (Old)\n\n\n\n\nlogic()\n\n\n\n\n...\n\n\n\n\n\n\nhost:d\nclientOld:l\n\n\n\n\n\n\n1 .Unloads library\n\n\n\n\n\n\nclientNew\n\n\n\n\n\n\nClient Plugin (New)\n\n\n\n\nlogic()\n\n\n\n\n...\n\n\n\n\n\n\nclientOld:l\nclientNew:l\n\n\n\n\n\n\n3. Pointer re\ndirected to new address\n\n\n\n\n\n\nclientNew\nhost:d\n\n\n\n\n\n\n2. Loads library with newer modified\n\n\n \ntimestamp\n\n\n\n\n\n\n\n\n\nThis might seem a little confusing, so let's go through step-by-step:\n\n\n\n\nIn the \ndeform()\n function, we're checking the current modification\n  timestamp of the \nclient plugin\n. If we detect that the current file's\n  timestamp is newer than the current one we have loaded in memory, we \nunload\n  the old one\n and \nload the new one into memory\n instead.\n\n\nWe then \nfix up the function pointer\n to the old \nlogic()\n method to\n  point to the address of the new \nlogic()\n function in memory. If this\n  doesn't make sense, I'll go over it in a bit. Basically, think of it as us\n  telling the host plugin that the old \nlogic()\n function is no longer valid\n  and that it should be looking at our new one instead that we just modified.\n\n\n\n\n\n\nFunction Pointers: the short version\n\n\nIf you're new to C/C++, you might not be familiar with what they are.\n\nFunction pointers\n are basically, as the name implies, \npointers to\nfunctions\n; they point to addresses of where the start of function calls\nlive in memory. They allow us to basically re-direct our code to call newer\nversions of functions that we create on-the-fly as required.\n\n\nI recommend \ngetting familar with them\n\nbefore continuing with this tutorial, as the concept is integral to this entire\nworkflow.\n\n\n\n\nUnderstanding how libraries work\n\n\nBefore we continue any further, let's take a moment to recap on how libraries\nwork in operating systems, especially since there are some important differences\nbetween how Windows/Linux/OSX handles them.\n\n\n\n\nWarning\n\n\nI am not an expert on how these things work by any stretch of the\nimagination, and I highly encourage you\nto\n\nread up on the subject\n\non your own as well to get a better understanding of the machinery\ninvolved. I will only cover what I think is important in understanding what\nwe'll be attempting to accomplish within the scope of this project.\n\n\n\n\nUnderstanding the executable\n\n\nYou know what an executable is; it's the thing you basically double-click on in\nyour file explorer to run a program. When you do that, the OS basically does\nsomething similar to the following (this is a grossly over-simplified\nexplanation of what is actually happening, but we'll gloss over that for now):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\noverview\n\n\n\n\n\n\nexe\n\n\n\n\n\n\n.exe file (PE format)\n\n\n\n\nheader\n\n\n\n\nintel code\n\n\n\n\nfixup table\n\n\n\n\n\n\nlinker\n\n\n\n\nDynamic linker\n\n\n\n\n\n\nexe:f\nlinker\n\n\n\n\n\n\n\n\n\n\nexe:i\nlinker\n\n\n\n\n\n\n\n\n\n\nmemory\n\n\n\n\n\n\nMemory (RAM)\n\n\n\n\nintel code\n\n\n\n\nfunction calls\n\n\n\n\n\n\nexecution\n\n\n\n\nCode runs\n\n\n\n\n\n\nmemory:i\nexecution\n\n\n\n\n\n\n\n\n\n\nwindowsCode\n\n\n\n\nWindows code\n\n\n\n\n\n\nwindowsCode\nlinker\n\n\n\n\n\n\ne.g. WinMain()\n\n\n\n\n\n\nlinker\nmemory:f\n\n\n\n\n\n\npatches over\n\n\n\n\n\n\nlinker\nmemory:i\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe file format on Windows for such file is known as\nthe \nPortable Executable\n\nformat, which is basically a standard layout for how a binary file should look\nlike so that the OS (in this case, Windows) knows how to look inside it and find\nthe stuff it needs.\n\n\n\n\nCrossing the platforms\n\n\nOn Linux/OSX, the file format used is known as the \nExecutable and Linkable\nFormat (ELF)\n.\nWhile not precisely the same as the Windows PE format, for our purposes, we\ncan assume that they function in a similar manner.\n\n\n\n\nYour \n.exe\n file that you compile contains various \nmemory segments\n. There\nis the \ndata section\n, the \ncode section\n, \nstack\n and the \nfixup table\n\n(also known as the \nimport address table\n). In it, there are assembly\ninstructions that make up the function calls that you've created in your source\ncode. These assembly instructions were generated when you compiled your source\ncode by whichever compiler you chose to use.\n\n\nWhen you click on that \n.exe\n file, Windows creates a new process for\nyou and maps the executable into that process' memory. Permissions are set for\nvarious sections of the data read in (i.e. the \ncode section\n is set to executable,\nthe \ndata\n section is read/write, and the \nstack/constants\n are\nread-only). It then looks at the \nfixup table\n that you have in your\nexecutable to see where your Windows/CRT function calls should be \npatched over\n\nin memory to point to the actual address of Windows functions (i.e. \nnot\n\ninside your executable!) So things like \nstrlen()\n, \nWinMain()\n and even\nthings like \nmalloc()\n all get executed this way.\n\n\nUnderstanding the library\n\n\nOK, whatever. So what has this got to do with libraries?\n\n\nFirst of all, let's get one thing straight: \na library is, for all intents and\npurposes, exactly the same thing as an executable\n. The major difference is\nthat the library is not directly executable (as the name implies), and a library\n(usually) doesn't need to define an entry point. Libraries basically contain the\nsame things that an executable does; in fact, on Windows, the \nDynamic Link\nLibrary (DLL)\n format (which is known as a \nshared library\n format) uses the\nexact same PE format that an \n.exe\n file does. The same is true for Linux as well,\nwhere \nShared Object (SO)\n and executables on Linux both share the ELF format.\n\n\nOne other difference is that typically, on Windows, a shared library \nexports\n\nspecific symbols for usage outside of itself through something called an\n\nexport table\n.\nThis exports table is what allows other executables like \nMaya.exe\n to be able\nto access the functions such as \ninitializePlugin\n and \nuninitalizePlugin\n\nin your \n.mll\n files (If you recall, you have to externalize these functions when\ncompiling your Maya plug-in as well!).\n\n\n\n\nCrossing the platforms\n\n\nOn Linux/OSX, \nall symbols in a \n.so\n file are available to an\ninterrogating process (i.e. Maya) by default\n. This means that we are able\nto lookup such symbols without the need for an export table unless we strip\nout the symbols manually; we'll talk about this later on during\nimplementation of our compilation scripts.\n\n\nOn this point, it's important to note that if it wasn't apparent,\nthe \n.mll\n and \n.dll\n extensions are essentially the same; Maya just\nwants a \n.mll\n extension for convention's sake; the file formats are\nidentical for both. On Linux, you should be aware that the convention for\nboth a Maya plug-in extension and a normal shared library is \n.so\n.\n\n\n\n\nThere are different types of libraries used for different purposes: \nstatic\n\nlibraries, which are libraries used during \nlinking\n and actually combined into\nthe final executable, and \ndynamic\n libraries, which are libraries that, as\nthe name implies, \ndynamically loaded\n either at \nload-time\n or \nrun-time\n\nrather than actually being combined into the main executable file.\n\n\nWe'll be focusing on dynamic link libraries in this tutorial, since they give us the\nproperties we'll need for code hotloading. If you'd like to learn more about the\ndifferences between the two and what they're each used for, I recommend \nreading\nup\n on\nthe \nsubject\n.\n\n\nIn addition to dynamic linking, there are two ways to perform this as well, known as\n\nload-time\n\ndynamic linking, and\n\nrun-time\n\ndynamic linking. For our purposes, we will be using \nrun-time\n dynamic\nlinking, which basically means that we will manage loading the DLL ourselves at\n\nrun-time\n, reading that DLL's available symbols, and mapping \nfunction pointers\n\nto point to those symbols.\n\n\nHow it all comes together\n\n\nSo when all is said and done, here's what things look like when we introduce a\nDLL to the mix:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\noverview\n\n\n\n\n\n\nexe\n\n\n\n\n\n\nMaya.exe file (PE format)\n\n\n\n\nheader\n\n\n\n\nintel code\n\n\n\n\nfixup table\n\n\n\n\n\n\nlinker\n\n\n\n\nDynamic linker\n\n\n\n\n\n\nexe:f:e\nlinker\n\n\n\n\n\n\n\n\n\n\nexe:i:e\nlinker\n\n\n\n\n\n\n\n\n\n\ndll\n\n\n\n\n\n\n.DLL file (PE format)\n\n\n\n\nheader\n\n\n\n\nintel code\n\n\n\n\nfixup table\n\n\n\n\n\n\nexports table\n\n\n\n\n\n\ndll\nexe\n\n\n\n\n\n\n \nTells OS to load the library into memory\n\n\n\n\n\n\ndll:et:s\nexe\n\n\n\n\n\n\n \nreads addresses of functions\n\n\n\n\n\n\ndll:i\nlinker\n\n\n\n\n\n\n\n\n\n\ndll:f:e\nlinker\n\n\n\n\n\n\n\n\n\n\nmemory\n\n\n\n\n\n\nMemory (RAM)\n\n\n\n\nintel code\n\n\n\n\nfunction calls\n\n\n\n\n\n\nexecution\n\n\n\n\nMaya runs\n\n\n\n\n\n\nmemory:i:e\nexecution:w\n\n\n\n\n\n\n\n\n\n\nwindowsCode\n\n\n\n\nWindows code\n\n\n\n\n\n\nwindowsCode\nlinker\n\n\n\n\n\n\n \nCalls here could be from either the DLL or Maya\n\n\n\n\n\n\nlinker\nmemory:f\n\n\n\n\n\n\n \npatches over\n\n\n\n\n\n\nlinker\nmemory:i\n\n\n\n\n\n\n\n\n\n\n\n\n\nSorry, GraphViz (which is what I use to generate these diagrams) is a little\ndifficult to wrangle into producing a nice shape\n.\n\n\nBasically, we see that things aren't that different; all that really happens is\nthat Maya will now load in our \n.dll\n library, read the addresses of functions\nfrom the exports table, presumably do whatever it needs to do (i.e. call\n\ndeform()\n or \ncompute()\n, for example), which then in turn the dynamic\nlinker will patch over with calls from Windows functions (if they happen to be\nused in those function calls), before finally executing the code from memory and\nthus performing the work we'd like (i.e. the mesh deforms, the animation plays,\nthe entire thing crashes etc.)\n\n\n\n\nTip\n\n\nCasey Muratori did a great job of giving a more Windows-specific generic\noverview of this entire topic on the Handmade Hero stream; I would highly\nrecommend watching it as well as he talks about other details that are of\ninterest, such as how memory paging works, along with the \nVirtual Memory\nAddress System (VMAS)\n, and the differences between \nphysical\n and\n\nvirtual\n memory. There are other things to learn, such as \nAddress Space\nLayout Randomization\n (ASLR), and all the other minutae related to those\nconcepts that we won't be covering within the scope of this tutorial.\n\n\nThe video is available \nhere\n.\n\n\n\n\nHopefully all of the above made some sense! Next, we'll finally get to start\nwriting some code to start to get this implemented, and in the process,\nhopefully learn a lot more about how memory works in general!.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting_started/#what-are-we-even-doing", 
            "text": "Here's  what's going down . The\nnormal approach for how a custom node in Maya would work would be something like\nthe following (connections that are called once are dashed, and connections that\nare called all the time are solid):        overview    Maya   Maya    host    Plugin DLL/SO   initializePlugin()   uninitializePlugin()   deform()   ...    host:ip Maya    Called when plugin is loaded    host:up Maya    Called when plugin is unloaded    host:d Maya    Called when node is dirtied     It's pretty straightforward; the plugin  Dynamic-link library (Windows/OSX) or\nShared Object (Linux)  contains all the initialization/uninitialization/deformation\nlogic/whatever necessary for the plugin to function; Maya just loads the entire binary,\ncalls the functions as needed whenever it determines it should, and that's the\nend of the story.  What we're going to be doing instead is something like the following:        overview    Maya   Maya    host    Host Plugin   initializePlugin()   uninitializePlugin()   deform()    host:ip Maya    Called on load    host:up Maya    Called on unload    host:d Maya    Called when dirtied    client    Client Plugin   logic()   ...    client:l host:d    Check last modified timestamp      Note  If the above didn't make any sense, please take a moment to review\nthe Autodesk documentation \nregarding how Maya plugins and their entry points work.   In this scenario, the  logic()  function will now contain all the  business\nlogic  necessary for the  deform()  function to work; the  deform() \nfunction itself will become pretty much nothing but a wrapper around Maya's\nmachinery. (For simplicity's sake, I will not be discussing taking the deform()  function out of the host plugin as well in this tutorial, though it\nis certainly possible, and I encourage you to try!)  OK, so far it's just a level of abstraction that we've introduced here. What\nhappens when we re-compile the client plugin?        overview    Maya   Maya    host    Host Plugin   initializePlugin()   uninitializePlugin()   deform()    host:ip Maya    Called on load    host:up Maya    Called on unload    host:d Maya    Called when dirtied    clientOld    Client Plugin (Old)   logic()   ...    host:d clientOld:l    1 .Unloads library    clientNew    Client Plugin (New)   logic()   ...    clientOld:l clientNew:l    3. Pointer re directed to new address    clientNew host:d    2. Loads library with newer modified    timestamp     This might seem a little confusing, so let's go through step-by-step:   In the  deform()  function, we're checking the current modification\n  timestamp of the  client plugin . If we detect that the current file's\n  timestamp is newer than the current one we have loaded in memory, we  unload\n  the old one  and  load the new one into memory  instead.  We then  fix up the function pointer  to the old  logic()  method to\n  point to the address of the new  logic()  function in memory. If this\n  doesn't make sense, I'll go over it in a bit. Basically, think of it as us\n  telling the host plugin that the old  logic()  function is no longer valid\n  and that it should be looking at our new one instead that we just modified.    Function Pointers: the short version  If you're new to C/C++, you might not be familiar with what they are. Function pointers  are basically, as the name implies,  pointers to\nfunctions ; they point to addresses of where the start of function calls\nlive in memory. They allow us to basically re-direct our code to call newer\nversions of functions that we create on-the-fly as required.  I recommend  getting familar with them \nbefore continuing with this tutorial, as the concept is integral to this entire\nworkflow.", 
            "title": "What are we even doing?"
        }, 
        {
            "location": "/getting_started/#understanding-how-libraries-work", 
            "text": "Before we continue any further, let's take a moment to recap on how libraries\nwork in operating systems, especially since there are some important differences\nbetween how Windows/Linux/OSX handles them.   Warning  I am not an expert on how these things work by any stretch of the\nimagination, and I highly encourage you\nto read up on the subject \non your own as well to get a better understanding of the machinery\ninvolved. I will only cover what I think is important in understanding what\nwe'll be attempting to accomplish within the scope of this project.", 
            "title": "Understanding how libraries work"
        }, 
        {
            "location": "/getting_started/#understanding-the-executable", 
            "text": "You know what an executable is; it's the thing you basically double-click on in\nyour file explorer to run a program. When you do that, the OS basically does\nsomething similar to the following (this is a grossly over-simplified\nexplanation of what is actually happening, but we'll gloss over that for now):        overview    exe    .exe file (PE format)   header   intel code   fixup table    linker   Dynamic linker    exe:f linker      exe:i linker      memory    Memory (RAM)   intel code   function calls    execution   Code runs    memory:i execution      windowsCode   Windows code    windowsCode linker    e.g. WinMain()    linker memory:f    patches over    linker memory:i       The file format on Windows for such file is known as\nthe  Portable Executable \nformat, which is basically a standard layout for how a binary file should look\nlike so that the OS (in this case, Windows) knows how to look inside it and find\nthe stuff it needs.   Crossing the platforms  On Linux/OSX, the file format used is known as the  Executable and Linkable\nFormat (ELF) .\nWhile not precisely the same as the Windows PE format, for our purposes, we\ncan assume that they function in a similar manner.   Your  .exe  file that you compile contains various  memory segments . There\nis the  data section , the  code section ,  stack  and the  fixup table \n(also known as the  import address table ). In it, there are assembly\ninstructions that make up the function calls that you've created in your source\ncode. These assembly instructions were generated when you compiled your source\ncode by whichever compiler you chose to use.  When you click on that  .exe  file, Windows creates a new process for\nyou and maps the executable into that process' memory. Permissions are set for\nvarious sections of the data read in (i.e. the  code section  is set to executable,\nthe  data  section is read/write, and the  stack/constants  are\nread-only). It then looks at the  fixup table  that you have in your\nexecutable to see where your Windows/CRT function calls should be  patched over \nin memory to point to the actual address of Windows functions (i.e.  not \ninside your executable!) So things like  strlen() ,  WinMain()  and even\nthings like  malloc()  all get executed this way.", 
            "title": "Understanding the executable"
        }, 
        {
            "location": "/getting_started/#understanding-the-library", 
            "text": "OK, whatever. So what has this got to do with libraries?  First of all, let's get one thing straight:  a library is, for all intents and\npurposes, exactly the same thing as an executable . The major difference is\nthat the library is not directly executable (as the name implies), and a library\n(usually) doesn't need to define an entry point. Libraries basically contain the\nsame things that an executable does; in fact, on Windows, the  Dynamic Link\nLibrary (DLL)  format (which is known as a  shared library  format) uses the\nexact same PE format that an  .exe  file does. The same is true for Linux as well,\nwhere  Shared Object (SO)  and executables on Linux both share the ELF format.  One other difference is that typically, on Windows, a shared library  exports \nspecific symbols for usage outside of itself through something called an export table .\nThis exports table is what allows other executables like  Maya.exe  to be able\nto access the functions such as  initializePlugin  and  uninitalizePlugin \nin your  .mll  files (If you recall, you have to externalize these functions when\ncompiling your Maya plug-in as well!).   Crossing the platforms  On Linux/OSX,  all symbols in a  .so  file are available to an\ninterrogating process (i.e. Maya) by default . This means that we are able\nto lookup such symbols without the need for an export table unless we strip\nout the symbols manually; we'll talk about this later on during\nimplementation of our compilation scripts.  On this point, it's important to note that if it wasn't apparent,\nthe  .mll  and  .dll  extensions are essentially the same; Maya just\nwants a  .mll  extension for convention's sake; the file formats are\nidentical for both. On Linux, you should be aware that the convention for\nboth a Maya plug-in extension and a normal shared library is  .so .   There are different types of libraries used for different purposes:  static \nlibraries, which are libraries used during  linking  and actually combined into\nthe final executable, and  dynamic  libraries, which are libraries that, as\nthe name implies,  dynamically loaded  either at  load-time  or  run-time \nrather than actually being combined into the main executable file.  We'll be focusing on dynamic link libraries in this tutorial, since they give us the\nproperties we'll need for code hotloading. If you'd like to learn more about the\ndifferences between the two and what they're each used for, I recommend  reading\nup  on\nthe  subject .  In addition to dynamic linking, there are two ways to perform this as well, known as load-time \ndynamic linking, and run-time \ndynamic linking. For our purposes, we will be using  run-time  dynamic\nlinking, which basically means that we will manage loading the DLL ourselves at run-time , reading that DLL's available symbols, and mapping  function pointers \nto point to those symbols.", 
            "title": "Understanding the library"
        }, 
        {
            "location": "/getting_started/#how-it-all-comes-together", 
            "text": "So when all is said and done, here's what things look like when we introduce a\nDLL to the mix:        overview    exe    Maya.exe file (PE format)   header   intel code   fixup table    linker   Dynamic linker    exe:f:e linker      exe:i:e linker      dll    .DLL file (PE format)   header   intel code   fixup table    exports table    dll exe      Tells OS to load the library into memory    dll:et:s exe      reads addresses of functions    dll:i linker      dll:f:e linker      memory    Memory (RAM)   intel code   function calls    execution   Maya runs    memory:i:e execution:w      windowsCode   Windows code    windowsCode linker      Calls here could be from either the DLL or Maya    linker memory:f      patches over    linker memory:i       Sorry, GraphViz (which is what I use to generate these diagrams) is a little\ndifficult to wrangle into producing a nice shape .  Basically, we see that things aren't that different; all that really happens is\nthat Maya will now load in our  .dll  library, read the addresses of functions\nfrom the exports table, presumably do whatever it needs to do (i.e. call deform()  or  compute() , for example), which then in turn the dynamic\nlinker will patch over with calls from Windows functions (if they happen to be\nused in those function calls), before finally executing the code from memory and\nthus performing the work we'd like (i.e. the mesh deforms, the animation plays,\nthe entire thing crashes etc.)   Tip  Casey Muratori did a great job of giving a more Windows-specific generic\noverview of this entire topic on the Handmade Hero stream; I would highly\nrecommend watching it as well as he talks about other details that are of\ninterest, such as how memory paging works, along with the  Virtual Memory\nAddress System (VMAS) , and the differences between  physical  and virtual  memory. There are other things to learn, such as  Address Space\nLayout Randomization  (ASLR), and all the other minutae related to those\nconcepts that we won't be covering within the scope of this tutorial.  The video is available  here .   Hopefully all of the above made some sense! Next, we'll finally get to start\nwriting some code to start to get this implemented, and in the process,\nhopefully learn a lot more about how memory works in general!.", 
            "title": "How it all comes together"
        }, 
        {
            "location": "/getting_somewhere/", 
            "text": "Getting somewhere\n\n\nOk, there's been a lot of text and diagrams. How about we finally start writing\nsome code?\n\n\n\n\nWarning\n\n\nThroughout the following code samples, I am purposely \nnot\n writing\nready-to-use code; if you want that, go to the Git repository itself and\nlook at the source files there. I am abbreviating code here for both\nlegibility reasons and also because I would rather you attempt to implement\nthe code yourself, rather than cargo-culting it wholesale and learning\nnothing in the process.\n\n\n\n\nMaking the basic plug-in setup\n\n\nFirstly, we'll just get a basic skeleton setup of the plugin going. We\nknow we're going to create a deformer plugin here, so that means we're going to\nneed a \nMPxGeometryFilter\n or \nMPxDeformerNode\n type of node. For\nsimplicity's sake, we'll go with a \nMPxGeometryFilter\n. As a refresher,\nyou first need to create a defintion that implements a creator\nfunction and an initializer function, which we will call \ncreator()\n and\n\ninitialize()\n respectively.\n\n\nThus, in \ndeformer.h\n:\n\n\n// We\nll use these to help us identify the node later on\n\n\nstatic\n \nconst\n \nMTypeId\n \nkHotReloadableDeformerID\n \n=\n \n0x0008002E\n;\n\n\nstatic\n \nconst\n \nchar\n \n*\nkHotReloadableDeformerName\n \n=\n \nhotReloadableDeformer\n;\n\n\n\n// Remember, in C++, a struct is the same thing as a class, except you type fewer\n\n\n// access specifiers!\n\n\nstruct\n \nHotReloadableDeformer\n \n:\n \nMPxGeometryFilter\n\n\n{\n\n    \nstatic\n \nvoid\n \n*\ncreator\n();\n\n\n    \nstatic\n \nMStatus\n \ninitialize\n();\n\n\n    \nMStatus\n \ndeform\n(\nMDataBlock\n \nblock\n,\n\n                   \nMItGeometry\n \niterator\n,\n\n                   \nconst\n \nMMatrix\n \nmatrix\n,\n\n                   \nunsigned\n \nint\n \nmultiIndex\n);\n\n\n}\n\n\n\n\n\n\nAnd \ndeformer.cpp\n, which, for now, looks pretty sparse:\n\n\n#include\n \ndeformer.h\n\n\n\nvoid\n \n*\nHotReloadableDeformer\n::\ncreator\n()\n\n\n{\n\n    \nreturn\n \nnew\n \nHotReloadableDeformer\n;\n\n\n}\n\n\n\n\nMStatus\n \nHotReloadableDeformer\n::\ninitialize\n()\n\n\n{\n\n    \nMStatus\n \nresult\n;\n\n    \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\nMStatus\n \nHotReloadableDeformer\n::\ndeform\n(\nMDataBlock\n \nblock\n,\n\n                                      \nMItGeometry\n \niter\n,\n\n                                      \nconst\n \nMMatrix\n \nmatrix\n,\n\n                                      \nunsigned\n \nint\n \nmultiIndex\n)\n\n\n{\n\n    \nMStatus\n \nresult\n;\n\n    \nfor\n \n(;\n \n!\niter\n.\nisDone\n();\n \niter\n.\nnext\n())\n\n    \n{\n\n\n        \nMPoint\n \ncurPtPosPt\n \n=\n \niter\n.\nposition\n();\n\n        \niter\n.\nsetPosition\n(\ncurPtPosPt\n);\n\n    \n}\n\n\n    \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\nGreat! We've got our node now, let's write the basic plugin structure to\nregister it. In case you needed a refresher:\n\n\nIn \nplugin_main.cpp\n:\n\n\n#include\n \nplugin_main.h\n\n\n#include\n \nmaya/MFnPlugin.h\n\n\n\nconst\n \nchar\n \n*\nkAUTHOR\n \n=\n \nMe, the author\n;\n\n\nconst\n \nchar\n \n*\nkVERSION\n \n=\n \n1.0.0\n;\n\n\nconst\n \nchar\n \n*\nkREQUIRED_API_VERSION\n \n=\n \nAny\n;\n\n\n\n\nMStatus\n \ninitializePlugin\n(\nMObject\n \nobj\n)\n\n\n{\n\n    \nMStatus\n \nstatus\n;\n\n    \nMFnPlugin\n \nplugin\n(\nobj\n,\n \nkAUTHOR\n,\n \nkVERSION\n,\n \nkREQUIRED_API_VERSION\n);\n\n\n    \nstatus\n \n=\n \nplugin\n.\nregisterNode\n(\nkHotReloadableDeformerName\n,\n\n                                 \nkHotReloadableDeformerID\n,\n\n                                 \nHotReloadableDeformer\n::\ncreator\n,\n\n                                 \nHotReloadableDeformer\n::\ninitialize\n,\n\n                                 \nMPxNode\n::\nkGeometryFilter\n);\n\n    \nCHECK_MSTATUS_AND_RETURN_IT\n(\nstatus\n);\n\n\n    \nreturn\n \nstatus\n;\n\n\n}\n\n\n\n\nMStatus\n \nuninitializePlugin\n(\nMObject\n \nobj\n)\n\n\n{\n\n    \nMFnPlugin\n \nplugin\n(\nobj\n);\n\n    \nMStatus\n \nstatus\n;\n\n\n    \nstatus\n \n=\n  \nplugin\n.\nderegisterNode\n(\nkHotReloadableDeformerID\n);\n\n    \nCHECK_MSTATUS_AND_RETURN_IT\n(\nstatus\n);\n\n\n    \nreturn\n \nstatus\n;\n\n\n}\n\n\n\n\n\n\nIn \nplugin_main.h\n, I go ahead and setup a \nSingle Translation Unit (STU)\nBuild/Unity build\n (which is easy, since there's only one\nsource file right now):\n\n\n#include\n \ndeformer.cpp\n\n\n\nMStatus\n \ninitializePlugin\n(\nMObject\n \nobj\n);\n\n\n\nMStatus\n \nuninitializePlugin\n(\nMObject\n \nobj\n);\n\n\n\n\n\n\n\n\nNote\n\n\nI will not go into the details regarding a STU build here, but suffice to say\nthat I have found them much more beneficial to build times than any other\ncompiler feature (LTO, IncrediBuild, splitting the code out into pre-compiled\nlibs, whatever). For such a small project, it doesn't matter; you can switch back\nto a more traditional build setup if you prefer.\n\n\n\n\nWriting the build script\n\n\nFor building this plugin, I'm going to go off-the-rails from what I usually do\nin my other tutorials and use a \nbuild.bat\n file. Yes, you read that right,\nwe're \nnot\n using CMake for once!\n\n\n...That comes later. For now, I'd like us to focus on \nwhat's actually\nhappening\n, rather than dealing with both that \nand\n the frustration of trying\nto get CMake to do what we want. (And it's good practice to be able to write in\nthe scripting language of the OS that you actually use! Trust me, if not for the\nVisual Studio project generation feature of CMake, I'd be using batch scripts on\nWindows anyway.)\n\n\n\n\nCrossing the platforms\n\n\nFor Linux/OSX users, you should (hopefully) be familiar enough with Bash\nscripting and GCC/Clang to write the equivalent commands as needed. If not,\nplease try to follow along for now or refer to the \nCMakeLists.txt\n in the\nrepository and convert that to your own build script as needed later on.\n\n\n\n\nWhat does this mean exactly? Well, we'll need to create a \nbuild.bat\n file,\nfor one thing. If you're used to building from within the Visual Studio IDE\nitself instead of from the command line, let's start from the very beginning\nhere and work our way through it step-by-step:\n\n\n@\necho\n off\n\nREM    Set up the Visual Studio environment variables for calling the MSVC compiler\n\n\ncall\n \n%vs2017installdir%\n\\VC\\Auxiliary\\Build\\vcvarsall.bat\n x64\n\n\nREM    Or maybe you\nre on VS 2015? Call this instead:\n\n\nREM call \nC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\vcvarsall.bat\n x64\n\n\n\nREM    Make a build directory to store artifacts; remember, %~dp0 is just a special\n\n\nREM    FOR variable reference in Windows that specifies the current directory the\n\n\nREM    batch script is being run in\n\n\nif\n \nnot\n \nexist\n \n%~dp0\nmsbuild \nmkdir\n \n%~dp0\nmsbuild\n\npushd\n \n%~dp0\nmsbuild\n\n\nREM    Obviously, change these to point to the proper locations for your filesystem\n\n\nset\n \nMayaRootDir\n=\nC:\\Program Files\\Autodesk\\Maya2016\n\nset\n \nMayaIncludeDir\n=\n%MayaRootDir%\n\\include\n\n\nset\n \nHostEntryPoint\n=\n%~dp0\nsrc\\plugin_main.cpp\n\n\nset\n \nOutputHostMLLFilename\n=\n%BuildDir%\n\\maya_hot_reload_example.mll\n\n\n\n\n\nSo far, so good: we first set up the Visual Studio environment by calling a\nconvenience batch script (which will allow us to call \ncl.exe\n and\n\nlink.exe\n from the command line directly, which are the MSVC compiler and\nlinker respectively), basically create a \nmsbuild\n directory if it doesn't\nexist, and set some basic constants up.\n\n\nLet's add a bit of code just to check if the user typed \ndebug\n or \nrelease\n\non the command line, so that we can build different configurations of the plugin\nas needed.\n\n\nREM Process command line arguments\n\n\nset\n \nBuildType\n=\n%1\n\n\nif\n \n%BuildType%\n==\n \n(\nset\n \nBuildType\n=\nrelease\n)\n\n\n\n\n\n\nNow\n it gets a little gnarly:\n\n\nREM    Setup all the compiler flags\n\n\nset\n \nCommonCompilerFlags\n=\n/c /MP /W3 /WX- /Gy /Zc:wchar_t /Zc:forScope /Zc:wchar_t /Zc:forScope /Zc:inline /openmp /fp:precise /nologo /EHsc /MD /D REQUIRE_IOSTREAM /D _CRT_SECURE_NO_WARNINGS /D _BOOL /D NT_PLUGIN /D _WINDLL /D _MBCS /Gm- /GS /Gy /Gd /TP\n\n\nREM    Add the include directories for header files\n\n\nset\n \nCommonCompilerFlags\n=\n%CommonCompilerFlags%\n /I\n%MayaRootDir%\n\\include\n\n\n\nset\n \nCommonCompilerFlagsDebug\n=\n/Zi /Od \n%CommonCompilerFlags%\n\n\nset\n \nCommonCompilerFlagsRelease\n=\n/O2 \n%CommonCompilerFlags%\n\n\n\nset\n \nCompilerFlagsHostDebug\n=\n%CommonCompilerFlagsDebug%\n \n%HostEntryPoint%\n\n\nset\n \nCompilerFlagsHostRelease\n=\n%CommonCompilerFlagsRelease%\n \n%HostEntryPoint%\n\n\n\n\n\n\nHoly compiler flags Batman\n, what is that wall of options? Basically, you can\n\ntake a look yourself\n,\nbut it's essentially the options we need to build a Maya plugin DLL. The\nimportant option (well, all of them are \ntechnically\n important) is the \n/I\n\ninclude directory option, which tells the compiler where to look for our \n.h\n\nheader files during compilation; we set that to the Maya headers include\ndirectory.\n\n\nWe also specify two different sets of compilation flags, one for \nRelease\n\nbuilds, and one for \nDebug\n builds, which both specify different optimization\noptions (the debug build will generate debugging information in the binary).\n\n\nHopefully that made sense, because the flags for the linker aren't any less complicated:\n\n\nREM    Setup all the linker flags\n\n\nset\n \nCommonLinkerFlags\n=\n /NOLOGO /INCREMENTAL:no /OPT:REF /MANIFEST /MANIFESTUAC:\nlevel=\nasInvoker\n uiAccess=\nfalse\n /manifest:embed /SUBSYSTEM:CONSOLE /TLBID:1 /DYNAMICBASE /NXCOMPAT /MACHINE:X64  /machine:x64 /DLL\n\n\nREM    Add all the Maya libraries to link against\n\n\nset\n \nCommonLinkerFlags\n=\n%CommonLinkerFlags%\n \n%MayaRootDir%\n\\lib\\OpenMaya.lib\n \n%MayaRootDir%\n\\lib\\OpenMayaAnim.lib\n \n%MayaRootDir%\n\\lib\\OpenMayaFX.lib\n \n%MayaRootDir%\n\\lib\\OpenMayaRender.lib\n \n%MayaRootDir%\n\\lib\\OpenMayaUI.lib\n \n%MayaRootDir%\n\\lib\\Foundation.lib\n \n%MayaRootDir%\n\\lib\\clew.lib\n \n%MayaRootDir%\n\\lib\\OpenMaya.lib\n \n%MayaRootDir%\n\\lib\\Image.lib\n \n%MayaRootDir%\n\\lib\\Foundation.lib\n \n%MayaRootDir%\n\\lib\\IMFbase.lib\n \n%MayaRootDir%\n\\lib\\OpenMaya.lib\n \n%MayaRootDir%\n\\lib\\OpenMayaAnim.lib\n \n%MayaRootDir%\n\\lib\\OpenMayaFX.lib\n \n%MayaRootDir%\n\\lib\\OpenMayaRender.lib\n \n%MayaRootDir%\n\\lib\\OpenMayaUI.lib\n \n%MayaRootDir%\n\\lib\\clew.lib\n \n%MayaRootDir%\n\\lib\\Image.lib\n \n%MayaRootDir%\n\\lib\\IMFbase.lib\n\n\n\nREM    Now add the OS libraries to link against\n\n\nset\n \nCommonLinkerFlags\n=\n%CommonLinkerFlags%\n Shlwapi.lib kernel32.lib user32.lib gdi32.lib winspool.lib shell32.lib ole32.lib oleaut32.lib uuid.lib comdlg32.lib advapi32.lib\n\n\nset\n \nCommonLinkerFlagsDebug\n=\n%CommonLinkerFlags%\n /DEBUG\n\nset\n \nCommonLinkerFlagsRelease\n=\n%CommonLinkerFlags%\n\n\n\nset\n \nCommonLinkerFlagsHost\n=\n/PDB:\n%BuildDir%\n\\maya_hot_reload_example.pdb\n /IMPLIB:\n%BuildDir%\n\\maya_hot_reload_example.lib\n /export:initializePlugin /export:uninitializePlugin \n%BuildDir%\n\\plugin_main.obj /OUT:\n%BuildDir%\n\\maya_hot_reload_example.mll\n\n\n\nset\n \nLinkerFlagsHostRelease\n=\n%CommonLinkerFlagsRelease%\n \n%CommonLinkerFlagsHost%\n\n\nset\n \nLinkerFlagsHostDebug\n=\n%CommonLinkerFlagsDebug%\n \n%CommonLinkerFlagsHost%\n\n\n\n\n\n\nAgain, MSDN is your friend to\n\nfind out what all those options do\n.\n\n\nIt's not that terribly complicated when we break it down a little: we bascially\nlink against all the static Maya libraries that we're supposed to (in order to\nbe able to call Maya functions in our DLL), along with the Windows static\nlibraries as well (in order to call Windows functions as well). We tell the\nlinker that we're building a DLL by specifying the \n/DLL\n flag, say that we\nwould like the linker to do some basic optimization through the \n/OPT:REF\n\nflag, and tell it to write the \nProgram Database (PDB)\n file out, along with\nspecifying the \nImport Library\n (i.e. \n*.lib\n file)and output DLL names\nexplicitly. If you're familiar with building a Maya plugin, you'll also notice\nthe infamous \ninitializePlugin\n and \nuninitializePlugin\n symbols being\nexported as well in the flags; these symbols \nmust\n be made visible in the DLL\nso that Maya can call the functions to load/unload the plugin respectively.\n\n\n\n\nCrossing the platforms\n\n\nThe\n\nProgram Database (PDB)\n\nfile is a Windows-specific file that is used by Visual Studio to look up\ninformation during a debugging session, such as the location of the source\nfiles, the positions within the source files that symbols correspond to, and\nother project information as well. They are the most commonly-used debug\nformat on Windows these days. Linux/OSX do not have this concept; the\ndebugging information is \"baked\" into the compiled binaries themselves.\n\n\n\n\nWe're not done yet; we need to actually compile and link \nsomething\n!\n\n\nif\n \n%BuildType%\n==\ndebug\n \n(\n\n    \necho\n Building in debug mode...\n    \nset\n \nCompilerFlagsHost\n=\n%CompilerFlagsHostDebug%\n\n    \nset\n \nLinkerFlagsHost\n=\n%LinkerFlagsHostDebug%\n\n\n    \nset\n \nCompilerFlagsLogic\n=\n%CompilerFlagsLogicDebug%\n\n    \nset\n \nLinkerFlagsLogic\n=\n%LinkerFlagsLogicDebug%\n\n\n)\n \nelse\n \n(\n\n    \necho\n Building in release mode...\n    \nset\n \nCompilerFlagsHost\n=\n%CompilerFlagsHostRelease%\n\n    \nset\n \nLinkerFlagsHost\n=\n%LinkerFlagsHostRelease%\n\n\n    \nset\n \nCompilerFlagsLogic\n=\n%CompilerFlagsLogicRelease%\n\n    \nset\n \nLinkerFlagsLogic\n=\n%LinkerFlagsLogicRelease%\n\n\n)\n\n\n\necho\n Compiling Host...\ncl \n%CompilerFlagsHost%\n\n\nif\n \n%errorlevel%\n \nneq\n 0 \nexit\n /b \n%errorlevel%\n\n\n\necho\n Linking Host...\nlink \n%LinkerFlagsHost%\n\n\nif\n \n%errorlevel%\n \nneq\n 0 \nexit\n /b \n%errorlevel%\n\n\n\n\necho\n Compiling Logic...\ncl \n%CompilerFlagsLogic%\n\n\nif\n \n%errorlevel%\n \nneq\n 0 \nexit\n /b \n%errorlevel%\n\n\n\necho\n Linking Logic...\nlink \n%LinkerFlagsLogic%\n\n\nif\n \n%errorlevel%\n \nneq\n 0 \nexit\n /b \n%errorlevel%\n\n\n\necho\n Build complete!\n\npopd\n\n\n\n\n\n\nLuckily, that's a \nlot\n easier once all the flags are set up. Whew!\n\n\nIf you got past all that and got a plugin building, great! We have a node that\ndoes...well, \nnothing\n.\n\n\nNow we just need to make it work.\n\n\nWriting the Client Plugin\n\n\nWe know from the previous section (and my fancy graphs)that we need a second DLL\nto handle the \nbusiness logic\n of the deformation. This client DLL will be\nreloaded by the \nHost DLL\n every time the timestamp on it changes, and the\n\nfunction pointers\n fixed up every time this happens. For simplicity's sake,\nlet's assume that all the business logic we'll be dealing with is just a\nfunction that takes a point from the \ndeform()\n function, does some work on\nit, and returns us a new position for it to be set at.\n\n\nLet's start with the first part of that sentence: making a second \nclient\nDLL\n.\n\n\nName mangling \n visibility\n\n\nIn \nlogic.h\n:\n\n\n#ifdef __cplusplus\n\n\n\n#define Shared extern \nC\n\n\n#define Import extern \nC\n\n\n\n#endif \n// __cplusplus\n\n\n\n\n/// DLL machinery types\n\n\n#ifdef _WIN32\n\n\n#include\n \nWindows.h\n\n\n\n#define DLLExport __declspec(dllexport)\n\n\n#define DLLImport __declspec(dllimport)\n\n\n\ntypedef\n \nHMODULE\n \nDLLHandle\n;\n\n\ntypedef\n \nFARPROC\n \nFuncPtr\n;\n\n\n\n#elif __linux__ || __APPLE__\n\n\n\n// NOTE: (sonictk) This will only work on GCC/Clang\n\n\n#define DLLExport __attribute__ ((visibility (\ndefault\n)))\n\n\n#define DLLImport __attribute__ ((visibility (\ndefault\n)))\n\n\n\ntypedef\n \nvoid\n \n*\n \nDLLHandle\n;\n\n\ntypedef\n \nvoid\n \n*\n \nFuncPtr\n;\n\n\n\n#endif \n/* Platform layer for DLL machinery */\n\n\n\n\nShared\n\n\n{\n\n    \nDLLExport\n \nMVector\n \ngetValue\n(\nMVector\n \nv\n,\n \nfloat\n \nfactor\n);\n\n\n}\n\n\n\n\n\n\nOk, what did we just add? Let's go over it bit-by-bit:\n\n\nextern \"C\"\n is basically a \nstorage class specifier\n that denotes \nexternal\nlanguage linkage\n. We \n#define\n the keyword \nShared\n to basically say that\n\"anytime we use the \nShared\n keyword, it means that we want the following\nsymbols that follow it to have external linkage, to be \nshared\n\". We give it\n\nC\n linkage, to avoid our symbol names getting \nmangled\n by the compiler; we\ndo want to be able to call them later on without having to type weird names like\n\n_ZN9getValue76E\n.\n\n\n\n\nName mangling\n\n\nIf you're new to C++, you might not be familiar with this term. Basically,\nbecause C++ supports \noverloading\n, the compiler \nmangles\n symbol names\nbased on their signatures to ensure that each overload ends up having a\nunique name, so that the compiler can mix and match the correct function\ncalls as needed based on the input arguments. More information on this\nfeature is available \nhere\n.\n\n\nThis also means that we should \nnot\n define overloaded versions of our\nbusiness logic functions, as the compiler won't know which version to use at\nlink time (This is also \nundefined behaviour\n, which means anything could happen!)\n\n\n\n\nOf course, this is C++, so things aren't as simple as that. We also define the\n\nDLLExport\n alias to do something called \n__declspec(dllexport)\n, which\nbasically is a directive to the MSVC compiler that tells it to export the given\nsymbols which use it. This will make the symbols available to the interrogating\nprocess that loads the DLL. (More information\n\nhere\n)\n\n\nWe also make two \ntypedef\ns: one for DLL handles, and one for function\npointers. These will use Windows-specific types, which are defined in \nWindows.h\n.\n\n\n\n\nCrossing the platforms\n\n\nOn Linux, we use the \nvisibility\n \n__attribute__\n directive instead,\nwhich GCC/Clang supports to achieve similar functionality. File handles and\nfunction pointers on Unix-based OSes are, thankfully, defined to use the\nbasic \nvoid\n pointer. It's of note here that by default, unless we\nspecifically strip the symbols ourselves, \nall symbols are available to an\ninterrogating process by default on Linux.\n The reason we still make use of\nthe visibility features is just in case we ever do decide to strip the\nsymbol information in the compilation process, the directive will continue\nto make sure it remains visible in the output binary.\n\n\nMore information on symbol visibility in GCC is available \nhere\n.\n\n\n\n\nWe're basically doing the same thing as we did above when specifying\n\ninitializePlugin\n and \nuninitializePlugin\n to be exported symbols, except\nthat we're doing it through code instead of the command line.\n\n\nSimple geometry\n\n\nLet's go ahead and implement \ngetValue\n in \nlogic.cpp\n now:\n\n\nMVector\n \nlerp\n(\nMVector\n \nv1\n,\n \nfloat\n \nt\n,\n \nMVector\n \nv2\n)\n\n\n{\n\n    \nMVector\n \nresult\n \n=\n \n((\n1.0f\n \n-\n \nt\n)\n \n*\n \nv1\n)\n \n+\n \n(\nt\n \n*\n \nv2\n);\n\n    \nreturn\n \nresult\n;\n\n\n}\n\n\n\nShared\n\n\n{\n\n    \nDLLExport\n \nMVector\n \ngetValue\n(\nMVector\n \nv\n,\n \nfloat\n \nfactor\n)\n\n    \n{\n\n        \nMVector\n \nresult\n;\n\n\n        \nresult\n.\nx\n \n=\n \nv\n.\nx\n \n*\n \n6\n;\n\n        \nresult\n.\ny\n \n=\n \nv\n.\ny\n \n*\n \n4\n;\n\n        \nresult\n.\nz\n \n=\n \nv\n.\nz\n \n*\n \n15\n;\n\n\n        \nresult\n \n=\n \nlerp\n(\nv\n,\n \nfactor\n,\n \nresult\n);\n\n\n        \nreturn\n \nresult\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAs we can see, it's pretty basic. Our business logic function essentially\n\nlinearly interpolates\n between a vector, and a non-uniformly scaled version of\nitself based on a normalized\nfactor\n value. As it happens, the default \nenvelope\n\nattribute on a Maya deformer is perfect for acting as the input to this\n\nfactor\n:\n\n\nMStatus\n \nHotReloadableDeformer\n::\ninitialize\n()\n\n\n{\n\n    \nMStatus\n \nresult\n;\n\n    \nattributeAffects\n(\nenvelope\n,\n \noutputGeom\n);\n\n\n    \nreturn\n \nresult\n;\n\n\n}\n\n\n\nMStatus\n \nHotReloadableDeformer\n::\ndeform\n(\nMDataBlock\n \nblock\n,\n\n                                      \nMItGeometry\n \niter\n,\n\n                                      \nconst\n \nMMatrix\n \nmatrix\n,\n\n                                      \nunsigned\n \nint\n \nmultiIndex\n)\n\n\n{\n\n    \nMStatus\n \nresult\n;\n\n\n    \nMDataHandle\n \nenvelopeHandle\n \n=\n \nblock\n.\ninputValue\n(\nenvelope\n,\n \nresult\n);\n\n    \nCHECK_MSTATUS_AND_RETURN_IT\n(\nresult\n);\n\n\n    \nfloat\n \nenvelope\n \n=\n \nenvelopeHandle\n.\nasFloat\n();\n\n\n    \nfor\n \n(;\n \n!\niter\n.\nisDone\n();\n \niter\n.\nnext\n())\n\n    \n{\n\n\n        \nMPoint\n \ncurPtPosPt\n \n=\n \niter\n.\nposition\n();\n\n        \n// Hmm...but how do we access getValue()?\n\n        \n// MVector finalPosPt = getValue(MVector(curPtPosPt), envelope);\n\n        \nMPoint\n \nfinalPosPt\n \n=\n \nMPoint\n(\nfinalPos\n.\nx\n,\n \nfinalPos\n.\ny\n,\n \nfinalPos\n.\nz\n,\n \n1\n);\n\n\n        \niter\n.\nsetPosition\n(\nfinalPosPt\n);\n\n    \n}\n\n\n    \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\nWe basically tell Maya that the \nenvelope\n attribute is going to end up\naffecting the geometry, and then...we realize that we can't actually call\n\ngetValue()\n, yet; at least, not without compiling both \nlogic.cpp\n and\n\nplugin_main.cpp\n within the same \nTranslation Unit (TU)\n so that we have\naccess to that symbol. So how are we going to do this?\n\n\nBuilding the plugin\n\n\nLet's worry about that later. For now, let's focus on compiling that\n\nlogic.cpp\n file we just wrote into its own DLL:\n\n\nREM    Previous stuff...\n\n\n\nset\n \nLogicEntryPoint\n=\n%~dp0\nsrc\\logic.cpp\n\n\nset\n \nOutputLogicDLLFilename\n=\n%BuildDir%\n\\logic.dll\n\n\nREM    Previous stuff...\n\n\n\nset\n \nCommonLinkerFlagsLogic\n=\n/PDB:\n%BuildDir%\n\\logic.pdb\n /IMPLIB:\n%BuildDir%\n\\logic.lib\n /OUT:\n%BuildDir%\n\\logic.dll\n \n%BuildDir%\n\\logic.obj\n\n\nREM    Previous stuff...\n\n\n\nset\n \nLinkerFlagsLogicRelease\n=\n%CommonLinkerFlagsRelease%\n \n%CommonLinkerFlagsLogic%\n\n\nset\n \nLinkerFlagsLogicDebug\n=\n%CommonLinkerFlagsDebug%\n \n%CommonLinkerFlagsLogic%\n\n\n\nREM   Previous stuff...\n\n\n\necho\n Compiling Logic...\ncl \n%CompilerFlagsLogic%\n\n\nif\n \n%errorlevel%\n \nneq\n 0 \nexit\n /b \n%errorlevel%\n\n\n\necho\n Linking Logic...\nlink \n%LinkerFlagsLogic%\n\n\nif\n \n%errorlevel%\n \nneq\n 0 \nexit\n /b \n%errorlevel%\n\n\n\n\n\n\nGo ahead and run \nbuild.bat debug\n. Hopefully, you should get the following\nfiles in your \nmsbuild\n folder:\n\n\nlogic.dll\nlogic.exp\nlogic.lib\nlogic.obj\nmaya_hot_reload_example.exp\nmaya_hot_reload_example.lib\nmaya_hot_reload_example.mll\nplugin_main.obj\n\n\n\n\n\n\n\nCrossing the platforms\n\n\nThe \n.exp\n file is known as an \nexports\n file, and the \n.lib\n file is\nan \nimport library\n. They are mainly used to resolve \ncircular exports\n,\nwhere a program exports to another program that it also imports from, or\nwhen more than two programs both import/export to each other; the linker\nneeds to know to resolve the dependencies at link-time. They contain\ninformation about exported functions and other constant data (such as global\nvariables). For our purposes, they are largely superfluous, but it is\nimportant to know about them when dealing with larger, more complicated\nsetups.\n\n\nAgain, Linux/OSX SOs do not have this sort of machinery; it is Windows-specific.\n\n\nMore information is available \nhere.\n\n\n\n\nTry loading the plugin into Maya and applying it to a deformer:\n\n\nfile\n \n-f\n \n-new\n;\n\n\n\nloadPlugin\n \nc:/Users/sonictk/Git/experiments/maya_hot_reload_example/msbuild/maya_hot_reload_example.dll\n;\n\n\n\npolySphere\n;\n\n\ndeformer\n \n-type\n \nhotReloadableDeformer\n;\n\n\n\n\n\n\nIf you've made it to this point, great! Let's move on to the next section, where\nwe'll start figuring out how to get access to that \ngetValue\n function from\nour main \ndeformer.cpp\n TU.", 
            "title": "Getting Somewhere"
        }, 
        {
            "location": "/getting_somewhere/#getting-somewhere", 
            "text": "Ok, there's been a lot of text and diagrams. How about we finally start writing\nsome code?   Warning  Throughout the following code samples, I am purposely  not  writing\nready-to-use code; if you want that, go to the Git repository itself and\nlook at the source files there. I am abbreviating code here for both\nlegibility reasons and also because I would rather you attempt to implement\nthe code yourself, rather than cargo-culting it wholesale and learning\nnothing in the process.", 
            "title": "Getting somewhere"
        }, 
        {
            "location": "/getting_somewhere/#making-the-basic-plug-in-setup", 
            "text": "Firstly, we'll just get a basic skeleton setup of the plugin going. We\nknow we're going to create a deformer plugin here, so that means we're going to\nneed a  MPxGeometryFilter  or  MPxDeformerNode  type of node. For\nsimplicity's sake, we'll go with a  MPxGeometryFilter . As a refresher,\nyou first need to create a defintion that implements a creator\nfunction and an initializer function, which we will call  creator()  and initialize()  respectively.  Thus, in  deformer.h :  // We ll use these to help us identify the node later on  static   const   MTypeId   kHotReloadableDeformerID   =   0x0008002E ;  static   const   char   * kHotReloadableDeformerName   =   hotReloadableDeformer ;  // Remember, in C++, a struct is the same thing as a class, except you type fewer  // access specifiers!  struct   HotReloadableDeformer   :   MPxGeometryFilter  { \n     static   void   * creator (); \n\n     static   MStatus   initialize (); \n\n     MStatus   deform ( MDataBlock   block , \n                    MItGeometry   iterator , \n                    const   MMatrix   matrix , \n                    unsigned   int   multiIndex );  }   And  deformer.cpp , which, for now, looks pretty sparse:  #include   deformer.h  void   * HotReloadableDeformer :: creator ()  { \n     return   new   HotReloadableDeformer ;  }  MStatus   HotReloadableDeformer :: initialize ()  { \n     MStatus   result ; \n     return   result ;  }  MStatus   HotReloadableDeformer :: deform ( MDataBlock   block , \n                                       MItGeometry   iter , \n                                       const   MMatrix   matrix , \n                                       unsigned   int   multiIndex )  { \n     MStatus   result ; \n     for   (;   ! iter . isDone ();   iter . next ()) \n     { \n\n         MPoint   curPtPosPt   =   iter . position (); \n         iter . setPosition ( curPtPosPt ); \n     } \n\n     return   result ;  }   Great! We've got our node now, let's write the basic plugin structure to\nregister it. In case you needed a refresher:  In  plugin_main.cpp :  #include   plugin_main.h  #include   maya/MFnPlugin.h  const   char   * kAUTHOR   =   Me, the author ;  const   char   * kVERSION   =   1.0.0 ;  const   char   * kREQUIRED_API_VERSION   =   Any ;  MStatus   initializePlugin ( MObject   obj )  { \n     MStatus   status ; \n     MFnPlugin   plugin ( obj ,   kAUTHOR ,   kVERSION ,   kREQUIRED_API_VERSION ); \n\n     status   =   plugin . registerNode ( kHotReloadableDeformerName , \n                                  kHotReloadableDeformerID , \n                                  HotReloadableDeformer :: creator , \n                                  HotReloadableDeformer :: initialize , \n                                  MPxNode :: kGeometryFilter ); \n     CHECK_MSTATUS_AND_RETURN_IT ( status ); \n\n     return   status ;  }  MStatus   uninitializePlugin ( MObject   obj )  { \n     MFnPlugin   plugin ( obj ); \n     MStatus   status ; \n\n     status   =    plugin . deregisterNode ( kHotReloadableDeformerID ); \n     CHECK_MSTATUS_AND_RETURN_IT ( status ); \n\n     return   status ;  }   In  plugin_main.h , I go ahead and setup a  Single Translation Unit (STU)\nBuild/Unity build  (which is easy, since there's only one\nsource file right now):  #include   deformer.cpp  MStatus   initializePlugin ( MObject   obj );  MStatus   uninitializePlugin ( MObject   obj );    Note  I will not go into the details regarding a STU build here, but suffice to say\nthat I have found them much more beneficial to build times than any other\ncompiler feature (LTO, IncrediBuild, splitting the code out into pre-compiled\nlibs, whatever). For such a small project, it doesn't matter; you can switch back\nto a more traditional build setup if you prefer.", 
            "title": "Making the basic plug-in setup"
        }, 
        {
            "location": "/getting_somewhere/#writing-the-build-script", 
            "text": "For building this plugin, I'm going to go off-the-rails from what I usually do\nin my other tutorials and use a  build.bat  file. Yes, you read that right,\nwe're  not  using CMake for once!  ...That comes later. For now, I'd like us to focus on  what's actually\nhappening , rather than dealing with both that  and  the frustration of trying\nto get CMake to do what we want. (And it's good practice to be able to write in\nthe scripting language of the OS that you actually use! Trust me, if not for the\nVisual Studio project generation feature of CMake, I'd be using batch scripts on\nWindows anyway.)   Crossing the platforms  For Linux/OSX users, you should (hopefully) be familiar enough with Bash\nscripting and GCC/Clang to write the equivalent commands as needed. If not,\nplease try to follow along for now or refer to the  CMakeLists.txt  in the\nrepository and convert that to your own build script as needed later on.   What does this mean exactly? Well, we'll need to create a  build.bat  file,\nfor one thing. If you're used to building from within the Visual Studio IDE\nitself instead of from the command line, let's start from the very beginning\nhere and work our way through it step-by-step:  @ echo  off REM    Set up the Visual Studio environment variables for calling the MSVC compiler  call   %vs2017installdir% \\VC\\Auxiliary\\Build\\vcvarsall.bat  x64 REM    Or maybe you re on VS 2015? Call this instead:  REM call  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\vcvarsall.bat  x64  REM    Make a build directory to store artifacts; remember, %~dp0 is just a special  REM    FOR variable reference in Windows that specifies the current directory the  REM    batch script is being run in  if   not   exist   %~dp0 msbuild  mkdir   %~dp0 msbuild pushd   %~dp0 msbuild REM    Obviously, change these to point to the proper locations for your filesystem  set   MayaRootDir = C:\\Program Files\\Autodesk\\Maya2016 set   MayaIncludeDir = %MayaRootDir% \\include set   HostEntryPoint = %~dp0 src\\plugin_main.cpp set   OutputHostMLLFilename = %BuildDir% \\maya_hot_reload_example.mll  So far, so good: we first set up the Visual Studio environment by calling a\nconvenience batch script (which will allow us to call  cl.exe  and link.exe  from the command line directly, which are the MSVC compiler and\nlinker respectively), basically create a  msbuild  directory if it doesn't\nexist, and set some basic constants up.  Let's add a bit of code just to check if the user typed  debug  or  release \non the command line, so that we can build different configurations of the plugin\nas needed.  REM Process command line arguments  set   BuildType = %1  if   %BuildType% ==   ( set   BuildType = release )   Now  it gets a little gnarly:  REM    Setup all the compiler flags  set   CommonCompilerFlags = /c /MP /W3 /WX- /Gy /Zc:wchar_t /Zc:forScope /Zc:wchar_t /Zc:forScope /Zc:inline /openmp /fp:precise /nologo /EHsc /MD /D REQUIRE_IOSTREAM /D _CRT_SECURE_NO_WARNINGS /D _BOOL /D NT_PLUGIN /D _WINDLL /D _MBCS /Gm- /GS /Gy /Gd /TP REM    Add the include directories for header files  set   CommonCompilerFlags = %CommonCompilerFlags%  /I %MayaRootDir% \\include  set   CommonCompilerFlagsDebug = /Zi /Od  %CommonCompilerFlags%  set   CommonCompilerFlagsRelease = /O2  %CommonCompilerFlags%  set   CompilerFlagsHostDebug = %CommonCompilerFlagsDebug%   %HostEntryPoint%  set   CompilerFlagsHostRelease = %CommonCompilerFlagsRelease%   %HostEntryPoint%   Holy compiler flags Batman , what is that wall of options? Basically, you can take a look yourself ,\nbut it's essentially the options we need to build a Maya plugin DLL. The\nimportant option (well, all of them are  technically  important) is the  /I \ninclude directory option, which tells the compiler where to look for our  .h \nheader files during compilation; we set that to the Maya headers include\ndirectory.  We also specify two different sets of compilation flags, one for  Release \nbuilds, and one for  Debug  builds, which both specify different optimization\noptions (the debug build will generate debugging information in the binary).  Hopefully that made sense, because the flags for the linker aren't any less complicated:  REM    Setup all the linker flags  set   CommonLinkerFlags =  /NOLOGO /INCREMENTAL:no /OPT:REF /MANIFEST /MANIFESTUAC: level= asInvoker  uiAccess= false  /manifest:embed /SUBSYSTEM:CONSOLE /TLBID:1 /DYNAMICBASE /NXCOMPAT /MACHINE:X64  /machine:x64 /DLL REM    Add all the Maya libraries to link against  set   CommonLinkerFlags = %CommonLinkerFlags%   %MayaRootDir% \\lib\\OpenMaya.lib   %MayaRootDir% \\lib\\OpenMayaAnim.lib   %MayaRootDir% \\lib\\OpenMayaFX.lib   %MayaRootDir% \\lib\\OpenMayaRender.lib   %MayaRootDir% \\lib\\OpenMayaUI.lib   %MayaRootDir% \\lib\\Foundation.lib   %MayaRootDir% \\lib\\clew.lib   %MayaRootDir% \\lib\\OpenMaya.lib   %MayaRootDir% \\lib\\Image.lib   %MayaRootDir% \\lib\\Foundation.lib   %MayaRootDir% \\lib\\IMFbase.lib   %MayaRootDir% \\lib\\OpenMaya.lib   %MayaRootDir% \\lib\\OpenMayaAnim.lib   %MayaRootDir% \\lib\\OpenMayaFX.lib   %MayaRootDir% \\lib\\OpenMayaRender.lib   %MayaRootDir% \\lib\\OpenMayaUI.lib   %MayaRootDir% \\lib\\clew.lib   %MayaRootDir% \\lib\\Image.lib   %MayaRootDir% \\lib\\IMFbase.lib  REM    Now add the OS libraries to link against  set   CommonLinkerFlags = %CommonLinkerFlags%  Shlwapi.lib kernel32.lib user32.lib gdi32.lib winspool.lib shell32.lib ole32.lib oleaut32.lib uuid.lib comdlg32.lib advapi32.lib set   CommonLinkerFlagsDebug = %CommonLinkerFlags%  /DEBUG set   CommonLinkerFlagsRelease = %CommonLinkerFlags%  set   CommonLinkerFlagsHost = /PDB: %BuildDir% \\maya_hot_reload_example.pdb  /IMPLIB: %BuildDir% \\maya_hot_reload_example.lib  /export:initializePlugin /export:uninitializePlugin  %BuildDir% \\plugin_main.obj /OUT: %BuildDir% \\maya_hot_reload_example.mll  set   LinkerFlagsHostRelease = %CommonLinkerFlagsRelease%   %CommonLinkerFlagsHost%  set   LinkerFlagsHostDebug = %CommonLinkerFlagsDebug%   %CommonLinkerFlagsHost%   Again, MSDN is your friend to find out what all those options do .  It's not that terribly complicated when we break it down a little: we bascially\nlink against all the static Maya libraries that we're supposed to (in order to\nbe able to call Maya functions in our DLL), along with the Windows static\nlibraries as well (in order to call Windows functions as well). We tell the\nlinker that we're building a DLL by specifying the  /DLL  flag, say that we\nwould like the linker to do some basic optimization through the  /OPT:REF \nflag, and tell it to write the  Program Database (PDB)  file out, along with\nspecifying the  Import Library  (i.e.  *.lib  file)and output DLL names\nexplicitly. If you're familiar with building a Maya plugin, you'll also notice\nthe infamous  initializePlugin  and  uninitializePlugin  symbols being\nexported as well in the flags; these symbols  must  be made visible in the DLL\nso that Maya can call the functions to load/unload the plugin respectively.   Crossing the platforms  The Program Database (PDB) \nfile is a Windows-specific file that is used by Visual Studio to look up\ninformation during a debugging session, such as the location of the source\nfiles, the positions within the source files that symbols correspond to, and\nother project information as well. They are the most commonly-used debug\nformat on Windows these days. Linux/OSX do not have this concept; the\ndebugging information is \"baked\" into the compiled binaries themselves.   We're not done yet; we need to actually compile and link  something !  if   %BuildType% == debug   ( \n     echo  Building in debug mode...\n     set   CompilerFlagsHost = %CompilerFlagsHostDebug% \n     set   LinkerFlagsHost = %LinkerFlagsHostDebug% \n\n     set   CompilerFlagsLogic = %CompilerFlagsLogicDebug% \n     set   LinkerFlagsLogic = %LinkerFlagsLogicDebug%  )   else   ( \n     echo  Building in release mode...\n     set   CompilerFlagsHost = %CompilerFlagsHostRelease% \n     set   LinkerFlagsHost = %LinkerFlagsHostRelease% \n\n     set   CompilerFlagsLogic = %CompilerFlagsLogicRelease% \n     set   LinkerFlagsLogic = %LinkerFlagsLogicRelease%  )  echo  Compiling Host...\ncl  %CompilerFlagsHost%  if   %errorlevel%   neq  0  exit  /b  %errorlevel%  echo  Linking Host...\nlink  %LinkerFlagsHost%  if   %errorlevel%   neq  0  exit  /b  %errorlevel%  echo  Compiling Logic...\ncl  %CompilerFlagsLogic%  if   %errorlevel%   neq  0  exit  /b  %errorlevel%  echo  Linking Logic...\nlink  %LinkerFlagsLogic%  if   %errorlevel%   neq  0  exit  /b  %errorlevel%  echo  Build complete! popd   Luckily, that's a  lot  easier once all the flags are set up. Whew!  If you got past all that and got a plugin building, great! We have a node that\ndoes...well,  nothing .  Now we just need to make it work.", 
            "title": "Writing the build script"
        }, 
        {
            "location": "/getting_somewhere/#writing-the-client-plugin", 
            "text": "We know from the previous section (and my fancy graphs)that we need a second DLL\nto handle the  business logic  of the deformation. This client DLL will be\nreloaded by the  Host DLL  every time the timestamp on it changes, and the function pointers  fixed up every time this happens. For simplicity's sake,\nlet's assume that all the business logic we'll be dealing with is just a\nfunction that takes a point from the  deform()  function, does some work on\nit, and returns us a new position for it to be set at.  Let's start with the first part of that sentence: making a second  client\nDLL .", 
            "title": "Writing the Client Plugin"
        }, 
        {
            "location": "/getting_somewhere/#name-mangling-visibility", 
            "text": "In  logic.h :  #ifdef __cplusplus  #define Shared extern  C  #define Import extern  C  #endif  // __cplusplus  /// DLL machinery types  #ifdef _WIN32  #include   Windows.h  #define DLLExport __declspec(dllexport)  #define DLLImport __declspec(dllimport)  typedef   HMODULE   DLLHandle ;  typedef   FARPROC   FuncPtr ;  #elif __linux__ || __APPLE__  // NOTE: (sonictk) This will only work on GCC/Clang  #define DLLExport __attribute__ ((visibility ( default )))  #define DLLImport __attribute__ ((visibility ( default )))  typedef   void   *   DLLHandle ;  typedef   void   *   FuncPtr ;  #endif  /* Platform layer for DLL machinery */  Shared  { \n     DLLExport   MVector   getValue ( MVector   v ,   float   factor );  }   Ok, what did we just add? Let's go over it bit-by-bit:  extern \"C\"  is basically a  storage class specifier  that denotes  external\nlanguage linkage . We  #define  the keyword  Shared  to basically say that\n\"anytime we use the  Shared  keyword, it means that we want the following\nsymbols that follow it to have external linkage, to be  shared \". We give it C  linkage, to avoid our symbol names getting  mangled  by the compiler; we\ndo want to be able to call them later on without having to type weird names like _ZN9getValue76E .   Name mangling  If you're new to C++, you might not be familiar with this term. Basically,\nbecause C++ supports  overloading , the compiler  mangles  symbol names\nbased on their signatures to ensure that each overload ends up having a\nunique name, so that the compiler can mix and match the correct function\ncalls as needed based on the input arguments. More information on this\nfeature is available  here .  This also means that we should  not  define overloaded versions of our\nbusiness logic functions, as the compiler won't know which version to use at\nlink time (This is also  undefined behaviour , which means anything could happen!)   Of course, this is C++, so things aren't as simple as that. We also define the DLLExport  alias to do something called  __declspec(dllexport) , which\nbasically is a directive to the MSVC compiler that tells it to export the given\nsymbols which use it. This will make the symbols available to the interrogating\nprocess that loads the DLL. (More information here )  We also make two  typedef s: one for DLL handles, and one for function\npointers. These will use Windows-specific types, which are defined in  Windows.h .   Crossing the platforms  On Linux, we use the  visibility   __attribute__  directive instead,\nwhich GCC/Clang supports to achieve similar functionality. File handles and\nfunction pointers on Unix-based OSes are, thankfully, defined to use the\nbasic  void  pointer. It's of note here that by default, unless we\nspecifically strip the symbols ourselves,  all symbols are available to an\ninterrogating process by default on Linux.  The reason we still make use of\nthe visibility features is just in case we ever do decide to strip the\nsymbol information in the compilation process, the directive will continue\nto make sure it remains visible in the output binary.  More information on symbol visibility in GCC is available  here .   We're basically doing the same thing as we did above when specifying initializePlugin  and  uninitializePlugin  to be exported symbols, except\nthat we're doing it through code instead of the command line.", 
            "title": "Name mangling &amp; visibility"
        }, 
        {
            "location": "/getting_somewhere/#simple-geometry", 
            "text": "Let's go ahead and implement  getValue  in  logic.cpp  now:  MVector   lerp ( MVector   v1 ,   float   t ,   MVector   v2 )  { \n     MVector   result   =   (( 1.0f   -   t )   *   v1 )   +   ( t   *   v2 ); \n     return   result ;  }  Shared  { \n     DLLExport   MVector   getValue ( MVector   v ,   float   factor ) \n     { \n         MVector   result ; \n\n         result . x   =   v . x   *   6 ; \n         result . y   =   v . y   *   4 ; \n         result . z   =   v . z   *   15 ; \n\n         result   =   lerp ( v ,   factor ,   result ); \n\n         return   result ; \n     }  }   As we can see, it's pretty basic. Our business logic function essentially linearly interpolates  between a vector, and a non-uniformly scaled version of\nitself based on a normalized factor  value. As it happens, the default  envelope \nattribute on a Maya deformer is perfect for acting as the input to this factor :  MStatus   HotReloadableDeformer :: initialize ()  { \n     MStatus   result ; \n     attributeAffects ( envelope ,   outputGeom ); \n\n     return   result ;  }  MStatus   HotReloadableDeformer :: deform ( MDataBlock   block , \n                                       MItGeometry   iter , \n                                       const   MMatrix   matrix , \n                                       unsigned   int   multiIndex )  { \n     MStatus   result ; \n\n     MDataHandle   envelopeHandle   =   block . inputValue ( envelope ,   result ); \n     CHECK_MSTATUS_AND_RETURN_IT ( result ); \n\n     float   envelope   =   envelopeHandle . asFloat (); \n\n     for   (;   ! iter . isDone ();   iter . next ()) \n     { \n\n         MPoint   curPtPosPt   =   iter . position (); \n         // Hmm...but how do we access getValue()? \n         // MVector finalPosPt = getValue(MVector(curPtPosPt), envelope); \n         MPoint   finalPosPt   =   MPoint ( finalPos . x ,   finalPos . y ,   finalPos . z ,   1 ); \n\n         iter . setPosition ( finalPosPt ); \n     } \n\n     return   result ;  }   We basically tell Maya that the  envelope  attribute is going to end up\naffecting the geometry, and then...we realize that we can't actually call getValue() , yet; at least, not without compiling both  logic.cpp  and plugin_main.cpp  within the same  Translation Unit (TU)  so that we have\naccess to that symbol. So how are we going to do this?", 
            "title": "Simple geometry"
        }, 
        {
            "location": "/getting_somewhere/#building-the-plugin", 
            "text": "Let's worry about that later. For now, let's focus on compiling that logic.cpp  file we just wrote into its own DLL:  REM    Previous stuff...  set   LogicEntryPoint = %~dp0 src\\logic.cpp set   OutputLogicDLLFilename = %BuildDir% \\logic.dll REM    Previous stuff...  set   CommonLinkerFlagsLogic = /PDB: %BuildDir% \\logic.pdb  /IMPLIB: %BuildDir% \\logic.lib  /OUT: %BuildDir% \\logic.dll   %BuildDir% \\logic.obj REM    Previous stuff...  set   LinkerFlagsLogicRelease = %CommonLinkerFlagsRelease%   %CommonLinkerFlagsLogic%  set   LinkerFlagsLogicDebug = %CommonLinkerFlagsDebug%   %CommonLinkerFlagsLogic%  REM   Previous stuff...  echo  Compiling Logic...\ncl  %CompilerFlagsLogic%  if   %errorlevel%   neq  0  exit  /b  %errorlevel%  echo  Linking Logic...\nlink  %LinkerFlagsLogic%  if   %errorlevel%   neq  0  exit  /b  %errorlevel%   Go ahead and run  build.bat debug . Hopefully, you should get the following\nfiles in your  msbuild  folder:  logic.dll\nlogic.exp\nlogic.lib\nlogic.obj\nmaya_hot_reload_example.exp\nmaya_hot_reload_example.lib\nmaya_hot_reload_example.mll\nplugin_main.obj   Crossing the platforms  The  .exp  file is known as an  exports  file, and the  .lib  file is\nan  import library . They are mainly used to resolve  circular exports ,\nwhere a program exports to another program that it also imports from, or\nwhen more than two programs both import/export to each other; the linker\nneeds to know to resolve the dependencies at link-time. They contain\ninformation about exported functions and other constant data (such as global\nvariables). For our purposes, they are largely superfluous, but it is\nimportant to know about them when dealing with larger, more complicated\nsetups.  Again, Linux/OSX SOs do not have this sort of machinery; it is Windows-specific.  More information is available  here.   Try loading the plugin into Maya and applying it to a deformer:  file   -f   -new ;  loadPlugin   c:/Users/sonictk/Git/experiments/maya_hot_reload_example/msbuild/maya_hot_reload_example.dll ;  polySphere ;  deformer   -type   hotReloadableDeformer ;   If you've made it to this point, great! Let's move on to the next section, where\nwe'll start figuring out how to get access to that  getValue  function from\nour main  deformer.cpp  TU.", 
            "title": "Building the plugin"
        }, 
        {
            "location": "/getting_into_it/", 
            "text": "Getting into it\n\n\nPicking up from the previous chapter, we got both a \nlogic.dll\n and a\n\nmaya_hot_reload_example.dll\n compiled and working, and (hopefully) loadable\nby Maya. Great!\n\n\nNow let's dive into what else the deformer needs to do:\n\n\n\n\n... we need a second DLL\nto handle the business logic of the deformation. \nThis client DLL will be\nreloaded by the Host DLL every time the timestamp on it changes\n, and the\nfunction pointers fixed up every time this happens.\n\n\n\n\nOK, let's focus on that next!\n\n\nChecking file modified timestamps\n\n\nRather than write some generic file-timestamp checking functions, let's take a\nmore data-oriented approach and \nwrite the client code first\n. What this means\nis basically, \"what would the code for such a thing even look like at the end of\nthe day?\"\n\n\nFirst, we're going to need to load the logic DLL. We're probably going to want\nto do this the moment the plugin is loaded, otherwise we wouldn't be able to do\nanything anyway. The \npostConstructor()\n virtual method is one possibility to\nutilize to achieve this goal:\n\n\n/// This is the global reference to the *business logic* DLL that is loaded.\n\n\nstatic\n \nDeformerLogicLibrary\n \nkLogicLibrary\n \n=\n \n{};\n\n\n\n\nvoid\n \nHotReloadableDeformer\n::\npostConstructor\n()\n\n\n{\n\n    \nLibraryStatus\n \nresult\n \n=\n \nloadDeformerLogicDLL\n(\nkLogicLibrary\n);\n\n    \nif\n \n(\nresult\n \n!=\n \nLibraryStatus_Success\n)\n \n{\n\n        \nMGlobal\n::\ndisplayError\n(\nFailed to load shared library!\n);\n\n        \nreturn\n;\n\n    \n}\n\n\n    \nreturn\n;\n\n\n}\n\n\n\n\n\n\nWhat is a \nLibraryStatus\n? It's nothing more complicated than a status code.\n\n\nenum\n \nLibraryStatus\n\n\n{\n\n    \nLibraryStatus_Failure\n \n=\n \nINT_MIN\n,\n\n    \nLibraryStatus_InvalidLibrary\n,\n\n    \nLibraryStatus_InvalidSymbol\n,\n\n    \nLibraryStatus_InvalidHandle\n,\n\n    \nLibraryStatus_UnloadFailure\n,\n\n    \nLibraryStatus_Success\n \n=\n \n0\n\n\n};\n\n\n\n\n\n\nAnd what is a \nDeformerLogicLibrary\n? It's a simple creature too:\n\n\ntypedef\n \nMVector\n \n(\n*\nDeformFunc\n)(\nMVector\n,\n \nfloat\n);\n\n\n\nstruct\n \nDeformerLogicLibrary\n\n\n{\n\n    \nDLLHandle\n \nhandle\n;\n\n    \nFileTime\n \nlastModified\n;\n\n\n    \nDeformFunc\n \ndeformCB\n;\n\n    \nbool\n \nisValid\n;\n\n\n};\n\n\n\n\n\n\nAs you can see, it's a mere data structure with pointers to the DLL handle, some\nsort of \nFileTime\n thing that basically tells us when the DLL was last\nmodified (so that we know if we need to reload it), a function pointer to the\nactual deformation business logic, and a boolean we can query to check if the\ndata is valid. Note that the signature of the function that the function pointer\npoints to matches the \ngetValue\n function that we previously defined.\n\n\nLet's focus now on what \nloadDeformerLogicDLL\n will actually do:\n\n\nLibraryStatus\n \nloadDeformerLogicDLL\n(\nDeformerLogicLibrary\n \nlibrary\n)\n\n\n{\n\n    \nconst\n \nchar\n \n*\nlibFilenameC\n \n=\n \nkPluginLogicLibraryPath\n.\nasChar\n();\n\n\n    \nFileTime\n \nlastModified\n \n=\n \ngetLastWriteTime\n(\nlibFilenameC\n);\n\n    \nlibrary\n.\nlastModified\n \n=\n \nlastModified\n;\n\n\n    \nDLLHandle\n \nhandle\n \n=\n \nloadSharedLibrary\n(\nlibFilenameC\n);\n\n    \nif\n \n(\n!\nhandle\n)\n \n{\n\n        \nMGlobal\n::\ndisplayError\n(\nUnable to load logic library!\n);\n\n        \nlibrary\n.\nhandle\n \n=\n \nNULL\n;\n\n        \nlibrary\n.\nlastModified\n \n=\n \n{};\n\n        \nlibrary\n.\nisValid\n \n=\n \nfalse\n;\n\n\n        \nreturn\n \nLibraryStatus_InvalidLibrary\n;\n\n    \n}\n\n\n    \nlibrary\n.\nhandle\n \n=\n \nhandle\n;\n\n\n    \nFuncPtr\n \ngetValueFuncAddr\n \n=\n \nloadSymbolFromLibrary\n(\nhandle\n,\n \ngetValue\n);\n\n    \nif\n \n(\n!\ngetValueFuncAddr\n)\n \n{\n\n        \nMGlobal\n::\ndisplayError\n(\nCould not find symbols in library!\n);\n\n        \nreturn\n \nLibraryStatus_InvalidSymbol\n;\n\n    \n}\n\n\n    \nlibrary\n.\ndeformCB\n \n=\n \n(\nDeformFunc\n)\ngetValueFuncAddr\n;\n\n    \nlibrary\n.\nisValid\n \n=\n \ntrue\n;\n\n\n    \nMGlobal\n::\ndisplayInfo\n(\nLoaded library from: \n \n+\n \nkPluginLogicLibraryPath\n);\n\n\n    \nreturn\n \nLibraryStatus_Success\n;\n\n\n}\n\n\n\n\n\n\nOk, a couple of things here: what is \nkPluginLogicLibraryPath\n? It's basically\nthe path to the logic library, which we'll assume to be in the same plugin as\nthe host DLL. Thus, we can retrieve it easily:\n\n\nMString\n \npluginPath\n \n=\n \nplugin\n.\nloadPath\n();\n\n\nconst\n \nchar\n \n*\npluginPathC\n \n=\n \npluginPath\n.\nasChar\n();\n\n\nconst\n \nsizet\n \nlenPluginPath\n \n=\n \nstrlen\n(\npluginPathC\n);\n\n\nchar\n \nOSPluginPath\n[\nkMaxPathLen\n];\n\n\nstrncpy\n(\nOSPluginPath\n,\n \npluginPathC\n,\n \nlenPluginPath\n \n+\n \n1\n);\n\n\nint\n \nreplaced\n \n=\n \nconvertPathSeparatorsToOSNative\n(\nOSPluginPath\n);\n\n\nif\n \n(\nreplaced\n \n \n0\n)\n \n{\n\n    \nMGlobal\n::\ndisplayError\n(\nFailed to format path of plugin to OS native version!\n);\n\n    \nreturn\n \nMStatus\n::\nkFailure\n;\n\n\n}\n\n\nif\n \n(\nstrlen\n(\nOSPluginPath\n)\n \n=\n \n0\n)\n \n{\n\n    \nMGlobal\n::\ndisplayError\n(\nCould not find a path to the plugin!\n);\n\n    \nreturn\n \nMStatus\n::\nkFailure\n;\n\n\n}\n\n\n\nkPluginLogicLibraryPath\n \n=\n \ngetDeformerLogicLibraryPath\n(\nOSPluginPath\n);\n\n\n\n\n\n\nThe source code for \nconvertPathSeparatorsToOSNative\n looks roughly like this:\n\n\nstatic\n \nconst\n \nchar\n \nkWin32PathSeparator\n \n=\n \n\\\\\n;\n\n\nstatic\n \nconst\n \nchar\n \nkPathDelimiter\n \n=\n \n\\\\\n;\n\n\n\n\ninline\n \nint\n \nstringReplace\n(\nconst\n \nchar\n \n*\ninput\n,\n\n                         \nchar\n \n*\noutput\n,\n\n                         \nconst\n \nchar\n \ntoken\n,\n\n                         \nconst\n \nchar\n \nreplace\n,\n\n                         \nunsigned\n \nint\n \nsize\n)\n\n\n{\n\n    \nsizet\n \nlen\n \n=\n \nstrlen\n(\ninput\n);\n\n    \nif\n \n(\nlen\n \n=\n \n0\n)\n \n{\n\n        \nreturn\n \n0\n;\n\n    \n}\n\n    \nint\n \nreplaced\n \n=\n \n0\n;\n\n    \nunsigned\n \nint\n \ni\n \n=\n \n0\n;\n\n    \nfor\n \n(;\n \ni\n \n \nsize\n \n \ni\n \n \n(\nlen\n \n+\n \n1\n)\n \n \ninput\n[\ni\n]\n \n!=\n \n\\0\n;\n \n++\ni\n)\n \n{\n\n        \nif\n \n(\ninput\n[\ni\n]\n \n==\n \ntoken\n)\n \n{\n\n            \noutput\n[\ni\n]\n \n=\n \nreplace\n;\n\n            \nreplaced\n++\n;\n\n        \n}\n \nelse\n \n{\n\n            \noutput\n[\ni\n]\n \n=\n \ninput\n[\ni\n];\n\n        \n}\n\n    \n}\n\n    \noutput\n[\ni\n]\n \n=\n \n\\0\n;\n\n\n    \nreturn\n \nreplaced\n;\n\n\n}\n\n\n\n\ninline\n \nint\n \nconvertPathSeparatorsToOSNative\n(\nchar\n \n*\nfilename\n)\n\n\n{\n\n    \nsizet\n \nlen\n \n=\n \nstrlen\n(\nfilename\n);\n\n    \nchar\n \ntmp\n[\nlen\n \n+\n \n1\n];\n\n    \nint\n \nreplaced\n \n=\n \nstringReplace\n(\nfilename\n,\n\n                                 \ntmp\n,\n\n                                 \nkWin32PathSeparator\n,\n\n                                 \nkPathDelimiter\n,\n\n                                 \n(\nunsigned\n \nint\n)\nlen\n \n+\n \n1\n);\n\n    \nif\n \n(\nreplaced\n \n=\n0\n)\n \n{\n\n        \nreturn\n \nreplaced\n;\n\n    \n}\n\n\n    \nstrncpy\n(\nfilename\n,\n \ntmp\n,\n \nlen\n \n+\n \n1\n);\n\n\n    \nreturn\n \nreplaced\n;\n\n\n}\n\n\n\n\n\n\nAnd that of \ngetDeformerLogicLibraryPath\n:\n\n\n#ifdef _WIN32\n\n\nglobalVar\n \nconst\n \nchar\n \n*\nkDeformerLogicLibraryName\n \n=\n \nlogic.dll\n;\n\n\n\n#elif __linux__ || __APPLE__\n\n\nglobalVar\n \nconst\n \nchar\n \n*\nkDeformerLogicLibraryName\n \n=\n \nlogic.so\n;\n\n\n\n#endif \n// Library filename\n\n\n\nMString\n \ngetDeformerLogicLibraryPath\n(\nconst\n \nchar\n \n*\npluginPath\n)\n\n\n{\n\n    \nif\n \n(\nstrlen\n(\npluginPath\n)\n \n=\n \n0\n)\n \n{\n\n        \nreturn\n \nMString\n();\n\n    \n}\n\n    \nchar\n \npathDelimiter\n[\n2\n]\n \n=\n \n{\nkPathDelimiter\n,\n \n\\0\n};\n\n    \nMString\n \ndelimiter\n(\npathDelimiter\n);\n\n    \nMString\n \npluginPathStr\n(\npluginPath\n);\n\n    \nMString\n \nlibFilename\n \n=\n \npluginPathStr\n \n+\n \ndelimiter\n \n+\n \nkDeformerLogicLibraryName\n;\n\n\n    \nreturn\n \nlibFilename\n;\n\n\n}\n\n\n\n\n\n\nWe basically have a bog-standard character-replacement function (since Maya\nreturns paths with Unix path separators by default) that helps us format a\nWindows path to the \nlogic.dll\n file.\n\n\nNow, let's take a look at what \ngetLastWriteTime\n looks like:\n\n\nWindows\n\n\nOn Windows, we make use of\nthe\n\nGetFileAttributesEx\n\ncall to retrieve the file's attributes, and get the last modified time from there.\n\n\ntypedef\n \nuint_64t\n \nFileTime\n;\n\n\n\n\ninline\n \nFileTime\n \ngetLastWriteTime\n(\nconst\n \nchar\n \n*\nfilename\n)\n\n\n{\n\n    \nFileTime\n \nresult\n \n=\n \n-\n1\n;\n\n\n    \nFILETIME\n \nlastWriteTime\n;\n\n    \nWIN32_FILE_ATTRIBUTE_DATA\n \ndata\n;\n\n    \nif\n \n(\nGetFileAttributesEx\n((\nLPCTSTR\n)\nfilename\n,\n \nGetFileExInfoStandard\n,\n \ndata\n))\n \n{\n\n        \nlastWriteTime\n \n=\n \ndata\n.\nftLastWriteTime\n;\n\n    \n}\n \nelse\n \n{\n\n        \nOSPrintLastError\n();\n\n        \nreturn\n \nresult\n;\n\n    \n}\n\n\n    \nresult\n \n=\n \n(\nFileTime\n)\nlastWriteTime\n.\ndwHighDateTime\n \n \nsizeof\n(\nDWORD\n)\n|\nlastWriteTime\n.\ndwLowDateTime\n;\n\n\n    \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\n\n\nWhy not use \nGetFileTime\n?\n\n\nFor those of you more familiar with the Win32 API, you might have noticed\nthe existence of a \nGetFileTime\n function that seems to do the same thing\nwe do here, except with less typing. The reason we don't use it is that it\nrequires a handle to the file, while \nGetFileAttributesEx\n does not.\n\n\n\n\nThe \nFILETIME\n structure on Windows is essentially two 32-bit integers smushed\ntogether, so we do some work to cast it to a single 64-bit value instead. For\nplatform compatbility's sake, we call that a \nFileTime\n data type of our own.\n\n\nOn Windows, \nOSPrintLastError\n looks like this:\n\n\ninline\n \nvoid\n \nOSPrintLastError\n()\n\n\n{\n\n    \nchar\n \nerrMsg\n[\n256\n];\n\n    \nDWORD\n \nerrCode\n \n=\n \nGetLastError\n();\n\n    \nif\n \n(\nerrCode\n \n==\n \n0\n)\n \n{\n\n        \nreturn\n;\n\n    \n}\n\n    \nFormatMessageA\n(\nFORMAT_MESSAGE_FROM_SYSTEM\n|\nFORMAT_MESSAGE_IGNORE_INSERTS\n,\n\n                   \nNULL\n,\n\n                   \nerrCode\n,\n\n                   \nMAKELANGID\n(\nLANG_NEUTRAL\n,\n \nSUBLANG_DEFAULT\n),\n\n                   \n(\nLPTSTR\n)\nerrMsg\n,\n\n                   \nsizeof\n(\nerrMsg\n),\n\n                   \nNULL\n);\n\n\n    \nperror\n(\nerrMsg\n);\n\n\n}\n\n\n\n\n\n\n(Yes, it's kind of a little silly how much you need to type to actually print a\nsystem exception string.)\n\n\nOn Windows, each tick is a 100-nanosecond interval, which is significantly more\ngranular than Linux's default legacy behaviour, which measures in 1-second\nintervals. Windows also starts its measurement from a different \nepoch\n than\nLinux; Windows uses \n1601-01-01T00:00:00Z\n as its start date, while Linux uses\n\n1970-01-01T00:00:00Z\n instead. This means that it's useful to define some\nconstants/functions for converting between the two:\n\n\n#define WINDOWS_TICK 10000000 \n// NOTE: (sonictk) Windows uses 100ns intervals\n\n\n#define SEC_TO_UNIX_EPOCH 11644473600LL\n\n\n\ninline\n \nuint\n \nwin32TicksToUnixSeconds\n(\ndlong\n \nwin32Ticks\n)\n\n\n{\n\n    \nreturn\n \n(\nuint\n)((\nwin32Ticks\n \n/\n \nWINDOWS_TICK\n)\n \n-\n \nSEC_TO_UNIX_EPOCH\n);\n\n\n}\n\n\n\n\ninline\n \ndlong\n \nunixSecondsToWin32Ticks\n(\nuint\n \nseconds\n)\n\n\n{\n\n    \nreturn\n \n(\ndlong\n)((\nseconds\n \n+\n \nSEC_TO_UNIX_EPOCH\n)\n \n*\n \nWINDOWS_TICK\n);\n\n\n}\n\n\n\ninline\n \ndlong\n \nunixSecondsToWin32Ticks\n(\ntimet\n \nseconds\n)\n\n\n{\n\n    \nreturn\n \nunixSecondsToWin32Ticks\n((\nuint\n)\nseconds\n);\n\n\n}\n\n\n\n\n\n\n\n\nCrossing the platforms\n\n\nWhy do we favour the Windows implementation when it comes to file times?\nWell, the Linux one suffers from\nthe \nYear 2038\n issue\n\ndue to its use of a single signed 32-bit integer, unlike Windows. This is\nrectified in newer versions of the kernel, but for backwards compatibility\nreasons, any code that relies on the legacy behaviour will fail to work in\nthe future.\n\n\n\n\nLinux\n\n\nWith that out of the way, the Linux implementation will look similar to the following:\n\n\ninline\n \nvoid\n \nOSPrintLastError\n()\n\n\n{\n\n    \nperror\n(\nstrerror\n(\nerrno\n));\n\n\n}\n\n\n\n\ninline\n \nFileTime\n \ngetLastWriteTime\n(\nconst\n \nchar\n \n*\nfilename\n)\n\n\n{\n\n    \nFileTime\n \nresult\n;\n\n\n    \nstruct\n \nstat\n \nattrib\n \n=\n \n{};\n\n    \nint\n \nstatResult\n \n=\n \nstat\n(\nfilename\n,\n \nattrib\n);\n\n    \nif\n \n(\nstatResult\n \n!=\n \n0\n)\n \n{\n\n        \nOSPrintLastError\n();\n\n    \n}\n\n    \ntimet\n \nmtime\n \n=\n \nattrib\n.\nst_mtim\n.\ntv_sec\n;\n\n\n    \nreturn\n \n(\nFileTime\n)(\nunixSecondsToWin32Ticks\n(\nmtime\n));\n\n\n}\n\n\n\n\n\n\nInstead of \nGetFileAttributesEx\n, which is a Windows-specific function, we\nmake use of \nstat\n instead to get\nourselves a \ntime_t\n structure that we can then extract the \nst_mtim\n field\nfrom, which is the last modified time.\n\n\nOk, we can now get file times of modified files on disk through code. Let's take\na look at what those mysterious \nloadSharedLibrary\n and \nloadSymbolFromLibrary\n\nfunctions do next.\n\n\nLoading a shared library\n\n\nWindows\n\n\nOn Windows, we load a shared libary using the function call \nLoadLibrary\n,\nfunnily enough! This makes implementation fairly trivial:\n\n\ninline\n \nDLLHandle\n \nloadSharedLibrary\n(\nconst\n \nchar\n \n*\nfilename\n)\n\n\n{\n\n    \nDLLHandle\n \nlibHandle\n \n=\n \nLoadLibrary\n((\nLPCTSTR\n)\nfilename\n);\n\n    \nif\n \n(\n!\nlibHandle\n)\n \n{\n\n        \nOSPrintLastError\n();\n\n        \nreturn\n \nNULL\n;\n\n    \n}\n\n\n    \nreturn\n \nlibHandle\n;\n\n\n}\n\n\n\n\n\n\nLet's do the unload equivalent as well using another function called\n\nFreeLibrary\n, which unloads the DLL from memory.\n\n\ninline\n \nint\n \nunloadSharedLibrary\n(\nDLLHandle\n \nhandle\n)\n\n\n{\n\n    \nif\n \n(\n!\nhandle\n)\n \n{\n\n        \nperror\n(\nThe handle is not valid! Cannot unload!\n\\n\n);\n\n        \nreturn\n \n-\n1\n;\n\n    \n}\n\n\n    \nBOOL\n \nresult\n \n=\n \nFreeLibrary\n(\nhandle\n);\n\n    \nif\n \n(\nresult\n \n==\n \n0\n)\n \n{\n\n        \nOSPrintLastError\n();\n\n        \nreturn\n \n-\n2\n;\n\n    \n}\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nNow that we can load a DLL into memory, we need a way to inspect that DLL and\nfind the address of a given symbol that we're interested in (like \ngetValue\n!)\nLet's see what that looks like in code:\n\n\ninline\n \nFuncPtr\n \nloadSymbolFromLibrary\n(\nDLLHandle\n \nhandle\n,\n \nconst\n \nchar\n \n*\nsymbol\n)\n\n\n{\n\n    \nFuncPtr\n \nsymbolAddr\n \n=\n \nGetProcAddress\n(\nhandle\n,\n \n(\nLPCSTR\n)\nsymbol\n);\n\n    \nif\n \n(\n!\nsymbolAddr\n)\n \n{\n\n        \nOSPrintLastError\n();\n\n    \n}\n\n\n    \nreturn\n \nsymbolAddr\n;\n\n\n}\n\n\n\n\n\n\nWe use the\nfunction\n\nGetProcAddress\n\nin order to perform run-time dynamic linking, getting the address of the symbol\nthat we're interested in. Thankfully, this entire process is fairly straightforward.\n\n\nLinux\n\n\nOn Linux, the process is very similar, except we use \ndlopen\n and \ndlclose\n\ninstead for our OS library calls:\n\n\n#include\n \ndlfcn.h\n\n\n\ninline\n \nDLLHandle\n \nloadSharedLibrary\n(\nconst\n \nchar\n \n*\nfilename\n,\n \nint\n \nflags\n)\n\n\n{\n\n    \nDLLHandle\n \nlibHandle\n \n=\n \ndlopen\n(\nfilename\n,\n \nflags\n);\n\n    \nif\n \n(\n!\nlibHandle\n)\n \n{\n\n        \nchar\n \n*\nerrMsg\n \n=\n \ndlerror\n();\n\n        \nfprintf\n(\nstderr\n,\n \nFailed to load library %s: %s!\n\\n\n,\n \nfilename\n,\n \nerrMsg\n);\n\n        \nreturn\n \nNULL\n;\n\n    \n}\n\n\n    \nreturn\n \nlibHandle\n;\n\n\n}\n\n\n\ninline\n \nDLLHandle\n \nloadSharedLibrary\n(\nconst\n \nchar\n \n*\nfilename\n)\n\n\n{\n\n    \nDLLHandle\n \nlibHandle\n \n=\n \nloadSharedLibrary\n(\nfilename\n,\n \nRTLD_LAZY\n);\n\n    \nreturn\n \nlibHandle\n;\n\n\n}\n\n\n\n\ninline\n \nint\n \nunloadSharedLibrary\n(\nDLLHandle\n \nhandle\n)\n\n\n{\n\n    \nif\n \n(\n!\nhandle\n)\n \n{\n\n        \nperror\n(\nThe handle is not valid! Cannot unload!\n\\n\n);\n\n        \nreturn\n \n-\n1\n;\n\n    \n}\n\n\n    \nint\n \nresult\n \n=\n \ndlclose\n(\nhandle\n);\n\n    \nif\n \n(\nresult\n \n!=\n \n0\n)\n \n{\n\n        \nchar\n \n*\nerrMsg\n \n=\n \ndlerror\n();\n\n        \nfprintf\n(\nstderr\n,\n \nCould not free library! %s\n\\n\n,\n \nerrMsg\n);\n\n    \n}\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nWe specify the \nRTLD_LAZY\n flag when loading our \n.so\n since we only want to\nresolve our \ngetValue\n symbol when code that references it is executed; if no\ncode ever references it, well, why would we want to waste time performing the\nbinding of symbols otherwise?\n\n\nWhen it comes to loading symbols at run-time, \ndlsym()\n is our function of\nchoice, however, Linux is slightly more obtuse when it comes to error-checking:\n\n\ninline\n \nFuncPtr\n \nloadSymbolFromLibrary\n(\nDLLHandle\n \nhandle\n,\n \nconst\n \nchar\n \n*\nsymbol\n)\n\n\n{\n\n    \nif\n \n(\n!\nhandle\n)\n \n{\n\n        \nperror\n(\nThe given handle was not valid!\n\\n\n);\n\n        \nreturn\n \nNULL\n;\n\n    \n}\n\n\n    \nvoid\n \n*\nsymbolAddr\n \n=\n \ndlsym\n(\nhandle\n,\n \nsymbol\n);\n\n    \nif\n \n(\nsymbolAddr\n \n==\n \nNULL\n)\n \n{\n\n        \ndlerror\n();\n\n        \ndlsym\n(\nhandle\n,\n \nsymbol\n);\n\n        \nchar\n \n*\nerrMsg\n \n=\n \ndlerror\n();\n\n        \nif\n \n(\n!\nerrMsg\n)\n \n{\n\n            \nreturn\n \nsymbolAddr\n;\n\n        \n}\n\n        \nfprintf\n(\nstderr\n,\n \nUnable to find symbol: %s! %s\n\\n\n,\n \nsymbol\n,\n \nerrMsg\n);\n\n\n        \nreturn\n \nNULL\n;\n\n    \n}\n\n\n    \nreturn\n \nsymbolAddr\n;\n\n\n}\n\n\n\n\n\n\nBasically, if the returned address was \nNULL\n, we clear the global status\ncode, call the \ndlsym\n function again, and check what the message is, since\nthe returned symbol might legimately \nbe\n a null pointer.\n\n\nPutting things together\n\n\nSo we've now got our \nloadDeformerLogicDLL\n sorted out, let's write the\nsymmetric \nunloadDeformerLogicDLL\n version:\n\n\nLibraryStatus\n \nunloadDeformerLogicDLL\n(\nDeformerLogicLibrary\n \nlibrary\n)\n\n\n{\n\n    \nif\n \n(\n!\nkLogicLibrary\n.\nisValid\n)\n \n{\n\n        \nreturn\n \nLibraryStatus_InvalidHandle\n;\n\n    \n}\n\n    \nint\n \nunload\n \n=\n \nunloadSharedLibrary\n(\nkLogicLibrary\n.\nhandle\n);\n\n    \nif\n \n(\nunload\n \n!=\n \n0\n)\n \n{\n\n        \nMGlobal\n::\ndisplayError\n(\nUnable to unload shared library!\n);\n\n        \nreturn\n \nLibraryStatus_UnloadFailure\n;\n\n    \n}\n\n\n    \nlibrary\n.\ndeformCB\n \n=\n \nNULL\n;\n\n    \nlibrary\n.\nlastModified\n \n=\n \n{};\n\n    \nlibrary\n.\nisValid\n \n=\n \nfalse\n;\n\n\n    \nreturn\n \nLibraryStatus_Success\n;\n\n\n}\n\n\n\n\n\n\nBasically, we check if the library given is valid, and unload it, thereafter\nclearing it out and re-initializing it to default values.\n\n\nWe can now update the main \ndeform()\n function to reload the DLL every time it\nchanges:\n\n\nMStatus\n \nHotReloadableDeformer\n::\ndeform\n(\nMDataBlock\n \nblock\n,\n\n                                      \nMItGeometry\n \niter\n,\n\n                                      \nconst\n \nMMatrix\n \nmatrix\n,\n\n                                      \nunsigned\n \nint\n \nmultiIndex\n)\n\n\n{\n\n    \nLibraryStatus\n \nstatus\n;\n\n\n    \nif\n \n(\n!\nkLogicLibrary\n.\nisValid\n)\n \n{\n\n        \nunloadDeformerLogicDLL\n(\nkLogicLibrary\n);\n\n        \nstatus\n \n=\n \nloadDeformerLogicDLL\n(\nkLogicLibrary\n);\n\n        \nif\n \n(\nstatus\n \n!=\n \nLibraryStatus_Success\n)\n \n{\n\n            \nreturn\n \nMStatus\n::\nkFailure\n;\n\n        \n}\n\n    \n}\n\n\n    \nif\n \n(\nkPluginLogicLibraryPath\n.\nnumChars\n()\n \n==\n \n0\n)\n \n{\n\n        \nreturn\n \nMStatus\n::\nkFailure\n;\n\n    \n}\n\n\n    \nFileTime\n \nlastModified\n \n=\n \ngetLastWriteTime\n(\nkPluginLogicLibraryPath\n.\nasChar\n());\n\n    \nif\n \n(\nlastModified\n \n=\n \n0\n \n \nlastModified\n \n!=\n \nkLogicLibrary\n.\nlastModified\n)\n \n{\n\n        \nstatus\n \n=\n \nunloadDeformerLogicDLL\n(\nkLogicLibrary\n);\n\n        \nif\n \n(\nstatus\n \n!=\n \nLibraryStatus_Success\n)\n \n{\n\n            \nreturn\n \nMStatus\n::\nkFailure\n;\n\n        \n}\n\n        \nstatus\n \n=\n \nloadDeformerLogicDLL\n(\nkLogicLibrary\n);\n\n        \nif\n \n(\nstatus\n \n!=\n \nLibraryStatus_Success\n)\n \n{\n\n            \nreturn\n \nMStatus\n::\nkFailure\n;\n\n        \n}\n\n    \n}\n\n\n    \nMStatus\n \nresult\n;\n\n\n    \nMDataHandle\n \nenvelopeHandle\n \n=\n \nblock\n.\ninputValue\n(\nenvelope\n,\n \nresult\n);\n\n    \nCHECK_MSTATUS_AND_RETURN_IT\n(\nresult\n);\n\n\n    \nfloat\n \nenvelope\n \n=\n \nenvelopeHandle\n.\nasFloat\n();\n\n\n    \nfor\n \n(;\n \n!\niter\n.\nisDone\n();\n \niter\n.\nnext\n())\n\n    \n{\n\n\n        \nMPoint\n \ncurPtPosPt\n \n=\n \niter\n.\nposition\n();\n\n        \nMPoint\n \nfinalPosPt\n \n=\n \nkLogicLibrary\n.\ndeformCB\n(\ncurPtPos\n,\n \nenvelope\n);\n\n\n        \niter\n.\nsetPosition\n(\nfinalPosPt\n);\n\n    \n}\n\n\n    \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\nThings might make more sense now. We check the last modified timestamp of the\ncurrent DLL file on disk and if it is newer than the one we have loaded in\nmemory, we unload the current one and load the new one instead. We modify the\ndeformation function to call our function pointer that we fixed up in the\n\nloadDeformerLogicDLL\n function as well.\n\n\nWe're almost done, but we've got some unfinished business to attend to in both\nour plugin entry/exit points:\n\n\nMStatus\n \ninitializePlugin\n(\nMObject\n \nobj\n)\n\n\n{\n\n    \nMStatus\n \nstatus\n;\n\n    \nMFnPlugin\n \nplugin\n(\nobj\n,\n \nkAUTHOR\n,\n \nkVERSION\n,\n \nkREQUIRED_API_VERSION\n);\n\n\n    \nMString\n \npluginPath\n \n=\n \nplugin\n.\nloadPath\n();\n\n    \nconst\n \nchar\n \n*\npluginPathC\n \n=\n \npluginPath\n.\nasChar\n();\n\n    \nconst\n \nsizet\n \nlenPluginPath\n \n=\n \nstrlen\n(\npluginPathC\n);\n\n    \nchar\n \nOSPluginPath\n[\nkMaxPathLen\n];\n\n    \nstrncpy\n(\nOSPluginPath\n,\n \npluginPathC\n,\n \nlenPluginPath\n \n+\n \n1\n);\n\n    \nint\n \nreplaced\n \n=\n \nconvertPathSeparatorsToOSNative\n(\nOSPluginPath\n);\n\n    \nif\n \n(\nreplaced\n \n \n0\n)\n \n{\n\n        \nreturn\n \nMStatus\n::\nkFailure\n;\n\n    \n}\n\n    \nif\n \n(\nstrlen\n(\nOSPluginPath\n)\n \n=\n \n0\n)\n \n{\n\n        \nreturn\n \nMStatus\n::\nkFailure\n;\n\n    \n}\n\n\n    \nkPluginLogicLibraryPath\n \n=\n \ngetDeformerLogicLibraryPath\n(\nOSPluginPath\n);\n\n\n    \nstatus\n \n=\n \nplugin\n.\nregisterNode\n(\nkHotReloadableDeformerName\n,\n\n                                 \nkHotReloadableDeformerID\n,\n\n                                 \nHotReloadableDeformer\n::\ncreator\n,\n\n                                 \nHotReloadableDeformer\n::\ninitialize\n,\n\n                                 \nMPxNode\n::\nkGeometryFilter\n);\n\n    \nCHECK_MSTATUS_AND_RETURN_IT\n(\nstatus\n);\n\n\n    \nreturn\n \nstatus\n;\n\n\n}\n\n\n\n\nMStatus\n \nuninitializePlugin\n(\nMObject\n \nobj\n)\n\n\n{\n\n    \nMFnPlugin\n \nplugin\n(\nobj\n);\n\n    \nMStatus\n \nstatus\n;\n\n\n    \nif\n \n(\nkLogicLibrary\n.\nisValid\n \n \nkLogicLibrary\n.\nhandle\n)\n \n{\n\n        \nunloadDeformerLogicDLL\n(\nkLogicLibrary\n);\n\n    \n}\n\n\n    \nstatus\n \n=\n  \nplugin\n.\nderegisterNode\n(\nkHotReloadableDeformerID\n);\n\n    \nCHECK_MSTATUS_AND_RETURN_IT\n(\nstatus\n);\n\n\n    \nreturn\n \nstatus\n;\n\n\n}\n\n\n\n\n\n\nBasically, we get the path to the \nlogic.dll\n and store it as a global\nvariable when our plugin is loaded (so we don't need to keep computing it each\ntime in the \ndeform\n function), and unload it when the plugin is unloaded.\n\n\nAt this point, our high-level implementation is complete. You can go ahead and\nload the plugin, change the \nlogic.cpp\n file and try to re-complile (and if\nyou're on Linux, things will probably work!) However, as they say, the devil is\nin the details, and there are two Windows-specific issues that we need to deal\nwith before we can reach a true hot-reloadable workflow.\n\n\nDealing with Windows\n\n\nDLL file handle lock\n\n\nYou might have noticed the following error message in your build output when you\ntried to run the \nbuild.bat\n script while the plugin was loaded in Maya:\n\n\nCompiling Logic...\nlogic.cpp\nLinking Logic...\nLINK : fatal error LNK1104: cannot open file \nC:\\Users\\sonictk\\Git\\experiments\\maya_hot_reload_example\\msbuild\\logic.dll\n\n\n\n\n\nUh-oh. Why is the linker complaining that it cannot open the business logic DLL?\n\n\nBasically, when we called \nLoadLibrary\n earlier, Windows will \nhelpfully\n lock\nthe file handle to it until it detects that there are no references left to it,\neither through the use of \nFreeLibrary\n calls (or all applications that\nreference it have crashed!) or otherwise. What this means is that while the DLL\nis in use, we can't overwrite it in-place.\n\n\nHowever...renaming a DLL file while it's in use does not invalidate the file\nhandle to it. Thus:\n\n\nif\n \nexist\n \n%OutputLogicDLLFilename%\n \n(\nrename\n \n%OutputLogicDLLFilename%\n \n%OutputLogicDLLTempFilename%\n)\n\n\n\nREM after compilation and everything...\n\n\ntimeout /t 1 \n NUL\n\n\necho\n Deleting temporary artifacts...\n\nif\n \nexist\n \n%OutputLogicDLLTempFilename%\n \ndel\n \n%OutputLogicDLLTempFilename%\n\n\n\n\n\n\nWe put a artificial wait time of 1 second to give Maya enough time to load the\nnew library before deleting the old one; unlike renaming, deleting a DLL while\nit's in use basically means undefined behaviour the next time an app requests\nmemory to/from it, and almost always results in a crash.\n\n\nYou can try now; things work as expected; we're able to modify \nlogic.cpp\n,\nre-run the build script, and watch the deformer update in real-time as the\n\ndeform\n function loads the new version of our library!\n\n\n\n\nCrossing the platforms\n\n\nWhy doesn't this problem occur on Linux? Basically, on Linux, when \n.so\ns\nare loaded into memory, we are able to overwrite the original file handle\nsince the mechanisms for reference counting work a little differently: the\n\ndirectory entry\n for the file gets removed, but any exsting processes that\nuse the file \nstill have access to the file itself\n. Only when the reference\ncount reaches zero does the file finally get deleted automatically by the\nOS. Linux does actually lock something called\nthe \ninode\n, which remains untouched,\nsince all we deleted was merely the link to it.\n\n\n\n\nPDB lock\n\n\nOne other problem is the issue of \nPDB lock\n; if we launched Maya under the\ncontrol of the Visual Studio debugger, or attached the debugger to Visual Studio\nwhile we were working with our plugin, we might get an error during compilation\nwhere the PDB file instead is the one being locked. What's happening is that\nVisual Studio will automatically lock any PDBs that are loaded during a\ndebugging session and \nwill keep them locked indefinitely until the end of the\ndebugging session\n. (This lock will persist even if you unload the DLL) This\n\npost\n\nhere details some possible solutions to this issue; we'll be making use of the\nthird one, which is to generate a random filename for the PDB file:\n\n\nset\n \nCommonLinkerFlagsLogic\n=\n/PDB:\n%BuildDir%\n\\logic_\n%random%\n.pdb\n /IMPLIB:\n%BuildDir%\n\\logic.lib\n /OUT:\n%BuildDir%\n\\logic.dll\n \n%BuildDir%\n\\logic.obj\n\n\n\n\n\nThe \n%random%\n macro on Windows will generate a random string of numbers for\nus, which will then be used in the resulting PDB's filename. What happens here\nis that the \nlogic.dll\n will now have the path to this new \n.pdb\n \"baked\"\ninside its debug section; the Visual Studio debugger will lock that file when a\ndebugging session is initiated. When we re-compile the PDB file, we generate a\nnew one and point to that one instead in the DLL, thus repeating the process\nand allowing us to get past the PDB lock.\n\n\n\n\nHow the debugger finds \n.pdb\n files\n\n\nI recommend reading up on how the Visual Studio\ndebugger\n\nfinds \n.pdb\n files\n\nin order to get a better understanding of the behaviour that's happening. Of\ncourse, keep in mind that this is Windows-specific; neither \ngdb\n nor\nXCode exhibit this behaviour.\n\n\n\n\nIs it working?\n\n\nIf you managed to get past all that, congratulations! You should be able to have\nhot-reloadable code working in your Maya deformer! If you're stuck somewhere,\ntake a look at the repository's code to see where you might have gone a bit\noff-base. (be warned, however, that the code there is organized a little bit\ndifferently from what you might have seen in this tutorial)\n\n\nGood luck, and I hope you've found this technique interesting (and perhaps useful)!", 
            "title": "Getting Into It"
        }, 
        {
            "location": "/getting_into_it/#getting-into-it", 
            "text": "Picking up from the previous chapter, we got both a  logic.dll  and a maya_hot_reload_example.dll  compiled and working, and (hopefully) loadable\nby Maya. Great!  Now let's dive into what else the deformer needs to do:   ... we need a second DLL\nto handle the business logic of the deformation.  This client DLL will be\nreloaded by the Host DLL every time the timestamp on it changes , and the\nfunction pointers fixed up every time this happens.   OK, let's focus on that next!", 
            "title": "Getting into it"
        }, 
        {
            "location": "/getting_into_it/#checking-file-modified-timestamps", 
            "text": "Rather than write some generic file-timestamp checking functions, let's take a\nmore data-oriented approach and  write the client code first . What this means\nis basically, \"what would the code for such a thing even look like at the end of\nthe day?\"  First, we're going to need to load the logic DLL. We're probably going to want\nto do this the moment the plugin is loaded, otherwise we wouldn't be able to do\nanything anyway. The  postConstructor()  virtual method is one possibility to\nutilize to achieve this goal:  /// This is the global reference to the *business logic* DLL that is loaded.  static   DeformerLogicLibrary   kLogicLibrary   =   {};  void   HotReloadableDeformer :: postConstructor ()  { \n     LibraryStatus   result   =   loadDeformerLogicDLL ( kLogicLibrary ); \n     if   ( result   !=   LibraryStatus_Success )   { \n         MGlobal :: displayError ( Failed to load shared library! ); \n         return ; \n     } \n\n     return ;  }   What is a  LibraryStatus ? It's nothing more complicated than a status code.  enum   LibraryStatus  { \n     LibraryStatus_Failure   =   INT_MIN , \n     LibraryStatus_InvalidLibrary , \n     LibraryStatus_InvalidSymbol , \n     LibraryStatus_InvalidHandle , \n     LibraryStatus_UnloadFailure , \n     LibraryStatus_Success   =   0  };   And what is a  DeformerLogicLibrary ? It's a simple creature too:  typedef   MVector   ( * DeformFunc )( MVector ,   float );  struct   DeformerLogicLibrary  { \n     DLLHandle   handle ; \n     FileTime   lastModified ; \n\n     DeformFunc   deformCB ; \n     bool   isValid ;  };   As you can see, it's a mere data structure with pointers to the DLL handle, some\nsort of  FileTime  thing that basically tells us when the DLL was last\nmodified (so that we know if we need to reload it), a function pointer to the\nactual deformation business logic, and a boolean we can query to check if the\ndata is valid. Note that the signature of the function that the function pointer\npoints to matches the  getValue  function that we previously defined.  Let's focus now on what  loadDeformerLogicDLL  will actually do:  LibraryStatus   loadDeformerLogicDLL ( DeformerLogicLibrary   library )  { \n     const   char   * libFilenameC   =   kPluginLogicLibraryPath . asChar (); \n\n     FileTime   lastModified   =   getLastWriteTime ( libFilenameC ); \n     library . lastModified   =   lastModified ; \n\n     DLLHandle   handle   =   loadSharedLibrary ( libFilenameC ); \n     if   ( ! handle )   { \n         MGlobal :: displayError ( Unable to load logic library! ); \n         library . handle   =   NULL ; \n         library . lastModified   =   {}; \n         library . isValid   =   false ; \n\n         return   LibraryStatus_InvalidLibrary ; \n     } \n\n     library . handle   =   handle ; \n\n     FuncPtr   getValueFuncAddr   =   loadSymbolFromLibrary ( handle ,   getValue ); \n     if   ( ! getValueFuncAddr )   { \n         MGlobal :: displayError ( Could not find symbols in library! ); \n         return   LibraryStatus_InvalidSymbol ; \n     } \n\n     library . deformCB   =   ( DeformFunc ) getValueFuncAddr ; \n     library . isValid   =   true ; \n\n     MGlobal :: displayInfo ( Loaded library from:    +   kPluginLogicLibraryPath ); \n\n     return   LibraryStatus_Success ;  }   Ok, a couple of things here: what is  kPluginLogicLibraryPath ? It's basically\nthe path to the logic library, which we'll assume to be in the same plugin as\nthe host DLL. Thus, we can retrieve it easily:  MString   pluginPath   =   plugin . loadPath ();  const   char   * pluginPathC   =   pluginPath . asChar ();  const   sizet   lenPluginPath   =   strlen ( pluginPathC );  char   OSPluginPath [ kMaxPathLen ];  strncpy ( OSPluginPath ,   pluginPathC ,   lenPluginPath   +   1 );  int   replaced   =   convertPathSeparatorsToOSNative ( OSPluginPath );  if   ( replaced     0 )   { \n     MGlobal :: displayError ( Failed to format path of plugin to OS native version! ); \n     return   MStatus :: kFailure ;  }  if   ( strlen ( OSPluginPath )   =   0 )   { \n     MGlobal :: displayError ( Could not find a path to the plugin! ); \n     return   MStatus :: kFailure ;  }  kPluginLogicLibraryPath   =   getDeformerLogicLibraryPath ( OSPluginPath );   The source code for  convertPathSeparatorsToOSNative  looks roughly like this:  static   const   char   kWin32PathSeparator   =   \\\\ ;  static   const   char   kPathDelimiter   =   \\\\ ;  inline   int   stringReplace ( const   char   * input , \n                          char   * output , \n                          const   char   token , \n                          const   char   replace , \n                          unsigned   int   size )  { \n     sizet   len   =   strlen ( input ); \n     if   ( len   =   0 )   { \n         return   0 ; \n     } \n     int   replaced   =   0 ; \n     unsigned   int   i   =   0 ; \n     for   (;   i     size     i     ( len   +   1 )     input [ i ]   !=   \\0 ;   ++ i )   { \n         if   ( input [ i ]   ==   token )   { \n             output [ i ]   =   replace ; \n             replaced ++ ; \n         }   else   { \n             output [ i ]   =   input [ i ]; \n         } \n     } \n     output [ i ]   =   \\0 ; \n\n     return   replaced ;  }  inline   int   convertPathSeparatorsToOSNative ( char   * filename )  { \n     sizet   len   =   strlen ( filename ); \n     char   tmp [ len   +   1 ]; \n     int   replaced   =   stringReplace ( filename , \n                                  tmp , \n                                  kWin32PathSeparator , \n                                  kPathDelimiter , \n                                  ( unsigned   int ) len   +   1 ); \n     if   ( replaced   = 0 )   { \n         return   replaced ; \n     } \n\n     strncpy ( filename ,   tmp ,   len   +   1 ); \n\n     return   replaced ;  }   And that of  getDeformerLogicLibraryPath :  #ifdef _WIN32  globalVar   const   char   * kDeformerLogicLibraryName   =   logic.dll ;  #elif __linux__ || __APPLE__  globalVar   const   char   * kDeformerLogicLibraryName   =   logic.so ;  #endif  // Library filename  MString   getDeformerLogicLibraryPath ( const   char   * pluginPath )  { \n     if   ( strlen ( pluginPath )   =   0 )   { \n         return   MString (); \n     } \n     char   pathDelimiter [ 2 ]   =   { kPathDelimiter ,   \\0 }; \n     MString   delimiter ( pathDelimiter ); \n     MString   pluginPathStr ( pluginPath ); \n     MString   libFilename   =   pluginPathStr   +   delimiter   +   kDeformerLogicLibraryName ; \n\n     return   libFilename ;  }   We basically have a bog-standard character-replacement function (since Maya\nreturns paths with Unix path separators by default) that helps us format a\nWindows path to the  logic.dll  file.  Now, let's take a look at what  getLastWriteTime  looks like:", 
            "title": "Checking file modified timestamps"
        }, 
        {
            "location": "/getting_into_it/#windows", 
            "text": "On Windows, we make use of\nthe GetFileAttributesEx \ncall to retrieve the file's attributes, and get the last modified time from there.  typedef   uint_64t   FileTime ;  inline   FileTime   getLastWriteTime ( const   char   * filename )  { \n     FileTime   result   =   - 1 ; \n\n     FILETIME   lastWriteTime ; \n     WIN32_FILE_ATTRIBUTE_DATA   data ; \n     if   ( GetFileAttributesEx (( LPCTSTR ) filename ,   GetFileExInfoStandard ,   data ))   { \n         lastWriteTime   =   data . ftLastWriteTime ; \n     }   else   { \n         OSPrintLastError (); \n         return   result ; \n     } \n\n     result   =   ( FileTime ) lastWriteTime . dwHighDateTime     sizeof ( DWORD ) | lastWriteTime . dwLowDateTime ; \n\n     return   result ;  }    Why not use  GetFileTime ?  For those of you more familiar with the Win32 API, you might have noticed\nthe existence of a  GetFileTime  function that seems to do the same thing\nwe do here, except with less typing. The reason we don't use it is that it\nrequires a handle to the file, while  GetFileAttributesEx  does not.   The  FILETIME  structure on Windows is essentially two 32-bit integers smushed\ntogether, so we do some work to cast it to a single 64-bit value instead. For\nplatform compatbility's sake, we call that a  FileTime  data type of our own.  On Windows,  OSPrintLastError  looks like this:  inline   void   OSPrintLastError ()  { \n     char   errMsg [ 256 ]; \n     DWORD   errCode   =   GetLastError (); \n     if   ( errCode   ==   0 )   { \n         return ; \n     } \n     FormatMessageA ( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS , \n                    NULL , \n                    errCode , \n                    MAKELANGID ( LANG_NEUTRAL ,   SUBLANG_DEFAULT ), \n                    ( LPTSTR ) errMsg , \n                    sizeof ( errMsg ), \n                    NULL ); \n\n     perror ( errMsg );  }   (Yes, it's kind of a little silly how much you need to type to actually print a\nsystem exception string.)  On Windows, each tick is a 100-nanosecond interval, which is significantly more\ngranular than Linux's default legacy behaviour, which measures in 1-second\nintervals. Windows also starts its measurement from a different  epoch  than\nLinux; Windows uses  1601-01-01T00:00:00Z  as its start date, while Linux uses 1970-01-01T00:00:00Z  instead. This means that it's useful to define some\nconstants/functions for converting between the two:  #define WINDOWS_TICK 10000000  // NOTE: (sonictk) Windows uses 100ns intervals  #define SEC_TO_UNIX_EPOCH 11644473600LL  inline   uint   win32TicksToUnixSeconds ( dlong   win32Ticks )  { \n     return   ( uint )(( win32Ticks   /   WINDOWS_TICK )   -   SEC_TO_UNIX_EPOCH );  }  inline   dlong   unixSecondsToWin32Ticks ( uint   seconds )  { \n     return   ( dlong )(( seconds   +   SEC_TO_UNIX_EPOCH )   *   WINDOWS_TICK );  }  inline   dlong   unixSecondsToWin32Ticks ( timet   seconds )  { \n     return   unixSecondsToWin32Ticks (( uint ) seconds );  }    Crossing the platforms  Why do we favour the Windows implementation when it comes to file times?\nWell, the Linux one suffers from\nthe  Year 2038  issue \ndue to its use of a single signed 32-bit integer, unlike Windows. This is\nrectified in newer versions of the kernel, but for backwards compatibility\nreasons, any code that relies on the legacy behaviour will fail to work in\nthe future.", 
            "title": "Windows"
        }, 
        {
            "location": "/getting_into_it/#linux", 
            "text": "With that out of the way, the Linux implementation will look similar to the following:  inline   void   OSPrintLastError ()  { \n     perror ( strerror ( errno ));  }  inline   FileTime   getLastWriteTime ( const   char   * filename )  { \n     FileTime   result ; \n\n     struct   stat   attrib   =   {}; \n     int   statResult   =   stat ( filename ,   attrib ); \n     if   ( statResult   !=   0 )   { \n         OSPrintLastError (); \n     } \n     timet   mtime   =   attrib . st_mtim . tv_sec ; \n\n     return   ( FileTime )( unixSecondsToWin32Ticks ( mtime ));  }   Instead of  GetFileAttributesEx , which is a Windows-specific function, we\nmake use of  stat  instead to get\nourselves a  time_t  structure that we can then extract the  st_mtim  field\nfrom, which is the last modified time.  Ok, we can now get file times of modified files on disk through code. Let's take\na look at what those mysterious  loadSharedLibrary  and  loadSymbolFromLibrary \nfunctions do next.", 
            "title": "Linux"
        }, 
        {
            "location": "/getting_into_it/#loading-a-shared-library", 
            "text": "", 
            "title": "Loading a shared library"
        }, 
        {
            "location": "/getting_into_it/#windows_1", 
            "text": "On Windows, we load a shared libary using the function call  LoadLibrary ,\nfunnily enough! This makes implementation fairly trivial:  inline   DLLHandle   loadSharedLibrary ( const   char   * filename )  { \n     DLLHandle   libHandle   =   LoadLibrary (( LPCTSTR ) filename ); \n     if   ( ! libHandle )   { \n         OSPrintLastError (); \n         return   NULL ; \n     } \n\n     return   libHandle ;  }   Let's do the unload equivalent as well using another function called FreeLibrary , which unloads the DLL from memory.  inline   int   unloadSharedLibrary ( DLLHandle   handle )  { \n     if   ( ! handle )   { \n         perror ( The handle is not valid! Cannot unload! \\n ); \n         return   - 1 ; \n     } \n\n     BOOL   result   =   FreeLibrary ( handle ); \n     if   ( result   ==   0 )   { \n         OSPrintLastError (); \n         return   - 2 ; \n     } \n\n     return   0 ;  }   Now that we can load a DLL into memory, we need a way to inspect that DLL and\nfind the address of a given symbol that we're interested in (like  getValue !)\nLet's see what that looks like in code:  inline   FuncPtr   loadSymbolFromLibrary ( DLLHandle   handle ,   const   char   * symbol )  { \n     FuncPtr   symbolAddr   =   GetProcAddress ( handle ,   ( LPCSTR ) symbol ); \n     if   ( ! symbolAddr )   { \n         OSPrintLastError (); \n     } \n\n     return   symbolAddr ;  }   We use the\nfunction GetProcAddress \nin order to perform run-time dynamic linking, getting the address of the symbol\nthat we're interested in. Thankfully, this entire process is fairly straightforward.", 
            "title": "Windows"
        }, 
        {
            "location": "/getting_into_it/#linux_1", 
            "text": "On Linux, the process is very similar, except we use  dlopen  and  dlclose \ninstead for our OS library calls:  #include   dlfcn.h  inline   DLLHandle   loadSharedLibrary ( const   char   * filename ,   int   flags )  { \n     DLLHandle   libHandle   =   dlopen ( filename ,   flags ); \n     if   ( ! libHandle )   { \n         char   * errMsg   =   dlerror (); \n         fprintf ( stderr ,   Failed to load library %s: %s! \\n ,   filename ,   errMsg ); \n         return   NULL ; \n     } \n\n     return   libHandle ;  }  inline   DLLHandle   loadSharedLibrary ( const   char   * filename )  { \n     DLLHandle   libHandle   =   loadSharedLibrary ( filename ,   RTLD_LAZY ); \n     return   libHandle ;  }  inline   int   unloadSharedLibrary ( DLLHandle   handle )  { \n     if   ( ! handle )   { \n         perror ( The handle is not valid! Cannot unload! \\n ); \n         return   - 1 ; \n     } \n\n     int   result   =   dlclose ( handle ); \n     if   ( result   !=   0 )   { \n         char   * errMsg   =   dlerror (); \n         fprintf ( stderr ,   Could not free library! %s \\n ,   errMsg ); \n     } \n\n     return   0 ;  }   We specify the  RTLD_LAZY  flag when loading our  .so  since we only want to\nresolve our  getValue  symbol when code that references it is executed; if no\ncode ever references it, well, why would we want to waste time performing the\nbinding of symbols otherwise?  When it comes to loading symbols at run-time,  dlsym()  is our function of\nchoice, however, Linux is slightly more obtuse when it comes to error-checking:  inline   FuncPtr   loadSymbolFromLibrary ( DLLHandle   handle ,   const   char   * symbol )  { \n     if   ( ! handle )   { \n         perror ( The given handle was not valid! \\n ); \n         return   NULL ; \n     } \n\n     void   * symbolAddr   =   dlsym ( handle ,   symbol ); \n     if   ( symbolAddr   ==   NULL )   { \n         dlerror (); \n         dlsym ( handle ,   symbol ); \n         char   * errMsg   =   dlerror (); \n         if   ( ! errMsg )   { \n             return   symbolAddr ; \n         } \n         fprintf ( stderr ,   Unable to find symbol: %s! %s \\n ,   symbol ,   errMsg ); \n\n         return   NULL ; \n     } \n\n     return   symbolAddr ;  }   Basically, if the returned address was  NULL , we clear the global status\ncode, call the  dlsym  function again, and check what the message is, since\nthe returned symbol might legimately  be  a null pointer.", 
            "title": "Linux"
        }, 
        {
            "location": "/getting_into_it/#putting-things-together", 
            "text": "So we've now got our  loadDeformerLogicDLL  sorted out, let's write the\nsymmetric  unloadDeformerLogicDLL  version:  LibraryStatus   unloadDeformerLogicDLL ( DeformerLogicLibrary   library )  { \n     if   ( ! kLogicLibrary . isValid )   { \n         return   LibraryStatus_InvalidHandle ; \n     } \n     int   unload   =   unloadSharedLibrary ( kLogicLibrary . handle ); \n     if   ( unload   !=   0 )   { \n         MGlobal :: displayError ( Unable to unload shared library! ); \n         return   LibraryStatus_UnloadFailure ; \n     } \n\n     library . deformCB   =   NULL ; \n     library . lastModified   =   {}; \n     library . isValid   =   false ; \n\n     return   LibraryStatus_Success ;  }   Basically, we check if the library given is valid, and unload it, thereafter\nclearing it out and re-initializing it to default values.  We can now update the main  deform()  function to reload the DLL every time it\nchanges:  MStatus   HotReloadableDeformer :: deform ( MDataBlock   block , \n                                       MItGeometry   iter , \n                                       const   MMatrix   matrix , \n                                       unsigned   int   multiIndex )  { \n     LibraryStatus   status ; \n\n     if   ( ! kLogicLibrary . isValid )   { \n         unloadDeformerLogicDLL ( kLogicLibrary ); \n         status   =   loadDeformerLogicDLL ( kLogicLibrary ); \n         if   ( status   !=   LibraryStatus_Success )   { \n             return   MStatus :: kFailure ; \n         } \n     } \n\n     if   ( kPluginLogicLibraryPath . numChars ()   ==   0 )   { \n         return   MStatus :: kFailure ; \n     } \n\n     FileTime   lastModified   =   getLastWriteTime ( kPluginLogicLibraryPath . asChar ()); \n     if   ( lastModified   =   0     lastModified   !=   kLogicLibrary . lastModified )   { \n         status   =   unloadDeformerLogicDLL ( kLogicLibrary ); \n         if   ( status   !=   LibraryStatus_Success )   { \n             return   MStatus :: kFailure ; \n         } \n         status   =   loadDeformerLogicDLL ( kLogicLibrary ); \n         if   ( status   !=   LibraryStatus_Success )   { \n             return   MStatus :: kFailure ; \n         } \n     } \n\n     MStatus   result ; \n\n     MDataHandle   envelopeHandle   =   block . inputValue ( envelope ,   result ); \n     CHECK_MSTATUS_AND_RETURN_IT ( result ); \n\n     float   envelope   =   envelopeHandle . asFloat (); \n\n     for   (;   ! iter . isDone ();   iter . next ()) \n     { \n\n         MPoint   curPtPosPt   =   iter . position (); \n         MPoint   finalPosPt   =   kLogicLibrary . deformCB ( curPtPos ,   envelope ); \n\n         iter . setPosition ( finalPosPt ); \n     } \n\n     return   result ;  }   Things might make more sense now. We check the last modified timestamp of the\ncurrent DLL file on disk and if it is newer than the one we have loaded in\nmemory, we unload the current one and load the new one instead. We modify the\ndeformation function to call our function pointer that we fixed up in the loadDeformerLogicDLL  function as well.  We're almost done, but we've got some unfinished business to attend to in both\nour plugin entry/exit points:  MStatus   initializePlugin ( MObject   obj )  { \n     MStatus   status ; \n     MFnPlugin   plugin ( obj ,   kAUTHOR ,   kVERSION ,   kREQUIRED_API_VERSION ); \n\n     MString   pluginPath   =   plugin . loadPath (); \n     const   char   * pluginPathC   =   pluginPath . asChar (); \n     const   sizet   lenPluginPath   =   strlen ( pluginPathC ); \n     char   OSPluginPath [ kMaxPathLen ]; \n     strncpy ( OSPluginPath ,   pluginPathC ,   lenPluginPath   +   1 ); \n     int   replaced   =   convertPathSeparatorsToOSNative ( OSPluginPath ); \n     if   ( replaced     0 )   { \n         return   MStatus :: kFailure ; \n     } \n     if   ( strlen ( OSPluginPath )   =   0 )   { \n         return   MStatus :: kFailure ; \n     } \n\n     kPluginLogicLibraryPath   =   getDeformerLogicLibraryPath ( OSPluginPath ); \n\n     status   =   plugin . registerNode ( kHotReloadableDeformerName , \n                                  kHotReloadableDeformerID , \n                                  HotReloadableDeformer :: creator , \n                                  HotReloadableDeformer :: initialize , \n                                  MPxNode :: kGeometryFilter ); \n     CHECK_MSTATUS_AND_RETURN_IT ( status ); \n\n     return   status ;  }  MStatus   uninitializePlugin ( MObject   obj )  { \n     MFnPlugin   plugin ( obj ); \n     MStatus   status ; \n\n     if   ( kLogicLibrary . isValid     kLogicLibrary . handle )   { \n         unloadDeformerLogicDLL ( kLogicLibrary ); \n     } \n\n     status   =    plugin . deregisterNode ( kHotReloadableDeformerID ); \n     CHECK_MSTATUS_AND_RETURN_IT ( status ); \n\n     return   status ;  }   Basically, we get the path to the  logic.dll  and store it as a global\nvariable when our plugin is loaded (so we don't need to keep computing it each\ntime in the  deform  function), and unload it when the plugin is unloaded.  At this point, our high-level implementation is complete. You can go ahead and\nload the plugin, change the  logic.cpp  file and try to re-complile (and if\nyou're on Linux, things will probably work!) However, as they say, the devil is\nin the details, and there are two Windows-specific issues that we need to deal\nwith before we can reach a true hot-reloadable workflow.", 
            "title": "Putting things together"
        }, 
        {
            "location": "/getting_into_it/#dealing-with-windows", 
            "text": "", 
            "title": "Dealing with Windows"
        }, 
        {
            "location": "/getting_into_it/#dll-file-handle-lock", 
            "text": "You might have noticed the following error message in your build output when you\ntried to run the  build.bat  script while the plugin was loaded in Maya:  Compiling Logic...\nlogic.cpp\nLinking Logic...\nLINK : fatal error LNK1104: cannot open file  C:\\Users\\sonictk\\Git\\experiments\\maya_hot_reload_example\\msbuild\\logic.dll  Uh-oh. Why is the linker complaining that it cannot open the business logic DLL?  Basically, when we called  LoadLibrary  earlier, Windows will  helpfully  lock\nthe file handle to it until it detects that there are no references left to it,\neither through the use of  FreeLibrary  calls (or all applications that\nreference it have crashed!) or otherwise. What this means is that while the DLL\nis in use, we can't overwrite it in-place.  However...renaming a DLL file while it's in use does not invalidate the file\nhandle to it. Thus:  if   exist   %OutputLogicDLLFilename%   ( rename   %OutputLogicDLLFilename%   %OutputLogicDLLTempFilename% )  REM after compilation and everything... \n\ntimeout /t 1   NUL echo  Deleting temporary artifacts... if   exist   %OutputLogicDLLTempFilename%   del   %OutputLogicDLLTempFilename%   We put a artificial wait time of 1 second to give Maya enough time to load the\nnew library before deleting the old one; unlike renaming, deleting a DLL while\nit's in use basically means undefined behaviour the next time an app requests\nmemory to/from it, and almost always results in a crash.  You can try now; things work as expected; we're able to modify  logic.cpp ,\nre-run the build script, and watch the deformer update in real-time as the deform  function loads the new version of our library!   Crossing the platforms  Why doesn't this problem occur on Linux? Basically, on Linux, when  .so s\nare loaded into memory, we are able to overwrite the original file handle\nsince the mechanisms for reference counting work a little differently: the directory entry  for the file gets removed, but any exsting processes that\nuse the file  still have access to the file itself . Only when the reference\ncount reaches zero does the file finally get deleted automatically by the\nOS. Linux does actually lock something called\nthe  inode , which remains untouched,\nsince all we deleted was merely the link to it.", 
            "title": "DLL file handle lock"
        }, 
        {
            "location": "/getting_into_it/#pdb-lock", 
            "text": "One other problem is the issue of  PDB lock ; if we launched Maya under the\ncontrol of the Visual Studio debugger, or attached the debugger to Visual Studio\nwhile we were working with our plugin, we might get an error during compilation\nwhere the PDB file instead is the one being locked. What's happening is that\nVisual Studio will automatically lock any PDBs that are loaded during a\ndebugging session and  will keep them locked indefinitely until the end of the\ndebugging session . (This lock will persist even if you unload the DLL) This post \nhere details some possible solutions to this issue; we'll be making use of the\nthird one, which is to generate a random filename for the PDB file:  set   CommonLinkerFlagsLogic = /PDB: %BuildDir% \\logic_ %random% .pdb  /IMPLIB: %BuildDir% \\logic.lib  /OUT: %BuildDir% \\logic.dll   %BuildDir% \\logic.obj  The  %random%  macro on Windows will generate a random string of numbers for\nus, which will then be used in the resulting PDB's filename. What happens here\nis that the  logic.dll  will now have the path to this new  .pdb  \"baked\"\ninside its debug section; the Visual Studio debugger will lock that file when a\ndebugging session is initiated. When we re-compile the PDB file, we generate a\nnew one and point to that one instead in the DLL, thus repeating the process\nand allowing us to get past the PDB lock.   How the debugger finds  .pdb  files  I recommend reading up on how the Visual Studio\ndebugger finds  .pdb  files \nin order to get a better understanding of the behaviour that's happening. Of\ncourse, keep in mind that this is Windows-specific; neither  gdb  nor\nXCode exhibit this behaviour.", 
            "title": "PDB lock"
        }, 
        {
            "location": "/getting_into_it/#is-it-working", 
            "text": "If you managed to get past all that, congratulations! You should be able to have\nhot-reloadable code working in your Maya deformer! If you're stuck somewhere,\ntake a look at the repository's code to see where you might have gone a bit\noff-base. (be warned, however, that the code there is organized a little bit\ndifferently from what you might have seen in this tutorial)  Good luck, and I hope you've found this technique interesting (and perhaps useful)!", 
            "title": "Is it working?"
        }, 
        {
            "location": "/demo/", 
            "text": "Demo\n\n\n\n\n\nYou can view a working demonstration of the entire setup \nhere\n.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/demo/#demo", 
            "text": "You can view a working demonstration of the entire setup  here .", 
            "title": "Demo"
        }, 
        {
            "location": "/conclusion/", 
            "text": "Closing Thoughts\n\n\nApplications\n\n\nSo, what else can this be used for other than deformers? Think about things like\nMaya MPxCommands; GUI widgets (via hooking the \nQEventLoop\n instead of the\n\ndeform\n/\ncompute\n functions), or even scene callbacks! \nThe possibilities\nare endless\n...for abuse, that is. While the overhead of constantly checking of\nan updated DLL is not significantly performance-draining, repeated checks across\nseveral DLLs could have an effect.\n\n\nIn my opinion, within the context of Maya, it's best to utilize this technique\nas a development aid, rather than something you leave enabled in shipping code,\ncontrolled via a simple preprocessor definition or similar mechanism.\n\n\nCurrent Limitations\n\n\nState transfer\n\n\nRight now, this little demonstration doesn't do anything to save any static\nstate across reloads of the DLL, nor does it handle adding new business logic\nfunctions and making those hot-loadable as well; you must maintain a defined set\nof entry points beforehand. There are several possible solutions to this;\n\ncr.h\n\nhandles this quite elegantly, and I might decide to take a similar approach as\nwell in the future.\n\n\nSingle-shot functions\n\n\nCertain functions in Maya, such as \ninitialize\n and \ncreator\n are called\nonly once when the node is created; as such, if we wanted to do things like add\nattributes to a node dynamically, we cannot utilize this existing approach of\nkeeping the update in the \ndeform\n function; we'd need to find a different way\nof not just making sure that the DLL is reloaded for that \ninitialize\n\nfunction, but also to make sure that all nodes in the scene are updated to point\nto that new \ninitialize\n function as well, along with making any modifications\nto memory that might entail. This is not a trivial problem to solve.\n\n\nCrash/Error handling\n\n\nRight now, we don't do any sort of crash handling in the DLL at all; this means\nthat if we accidentally compile code that executes UB, we could end up crashing\nMaya very easily. One thing to look into is to possibly catch such crash\nsignals, and if so, load a previous known good working version of the DLL and\nattempt to continue execution. Again, \ncr.h\n has some implementation of this\nwork as well; I might take a stab at porting it over to a Maya implementation in\nthe future.\n\n\nConclusion\n\n\nEven with all the downsides and possible crashes, to me, being able to\ncontinuously work on your code and watch it update live 5 out of 10 times is\nbetter than having to unload/reload 10 out of 10 times; I've been utilizing this\napproach recently when writing a deformer on my own project, and I'm definitely\nfar more productive than when I work conventionally, even with all my build\nshortcuts and tests.\n\n\nIn summary, I hope you've learned a little more about memory and how it works\nover the course of this tutorial, whether or not you choose to implement this\ndevelopment technique in production! Feel free to contact me or file questions\non the repository page; I know I'm not the greatest when it comes to explaining stuff.", 
            "title": "Closing thoughts"
        }, 
        {
            "location": "/conclusion/#closing-thoughts", 
            "text": "", 
            "title": "Closing Thoughts"
        }, 
        {
            "location": "/conclusion/#applications", 
            "text": "So, what else can this be used for other than deformers? Think about things like\nMaya MPxCommands; GUI widgets (via hooking the  QEventLoop  instead of the deform / compute  functions), or even scene callbacks!  The possibilities\nare endless ...for abuse, that is. While the overhead of constantly checking of\nan updated DLL is not significantly performance-draining, repeated checks across\nseveral DLLs could have an effect.  In my opinion, within the context of Maya, it's best to utilize this technique\nas a development aid, rather than something you leave enabled in shipping code,\ncontrolled via a simple preprocessor definition or similar mechanism.", 
            "title": "Applications"
        }, 
        {
            "location": "/conclusion/#current-limitations", 
            "text": "", 
            "title": "Current Limitations"
        }, 
        {
            "location": "/conclusion/#state-transfer", 
            "text": "Right now, this little demonstration doesn't do anything to save any static\nstate across reloads of the DLL, nor does it handle adding new business logic\nfunctions and making those hot-loadable as well; you must maintain a defined set\nof entry points beforehand. There are several possible solutions to this; cr.h \nhandles this quite elegantly, and I might decide to take a similar approach as\nwell in the future.", 
            "title": "State transfer"
        }, 
        {
            "location": "/conclusion/#single-shot-functions", 
            "text": "Certain functions in Maya, such as  initialize  and  creator  are called\nonly once when the node is created; as such, if we wanted to do things like add\nattributes to a node dynamically, we cannot utilize this existing approach of\nkeeping the update in the  deform  function; we'd need to find a different way\nof not just making sure that the DLL is reloaded for that  initialize \nfunction, but also to make sure that all nodes in the scene are updated to point\nto that new  initialize  function as well, along with making any modifications\nto memory that might entail. This is not a trivial problem to solve.", 
            "title": "Single-shot functions"
        }, 
        {
            "location": "/conclusion/#crasherror-handling", 
            "text": "Right now, we don't do any sort of crash handling in the DLL at all; this means\nthat if we accidentally compile code that executes UB, we could end up crashing\nMaya very easily. One thing to look into is to possibly catch such crash\nsignals, and if so, load a previous known good working version of the DLL and\nattempt to continue execution. Again,  cr.h  has some implementation of this\nwork as well; I might take a stab at porting it over to a Maya implementation in\nthe future.", 
            "title": "Crash/Error handling"
        }, 
        {
            "location": "/conclusion/#conclusion", 
            "text": "Even with all the downsides and possible crashes, to me, being able to\ncontinuously work on your code and watch it update live 5 out of 10 times is\nbetter than having to unload/reload 10 out of 10 times; I've been utilizing this\napproach recently when writing a deformer on my own project, and I'm definitely\nfar more productive than when I work conventionally, even with all my build\nshortcuts and tests.  In summary, I hope you've learned a little more about memory and how it works\nover the course of this tutorial, whether or not you choose to implement this\ndevelopment technique in production! Feel free to contact me or file questions\non the repository page; I know I'm not the greatest when it comes to explaining stuff.", 
            "title": "Conclusion"
        }, 
        {
            "location": "/credits/", 
            "text": "Credits\n\n\nThis is neither a new idea, nor is it in any way revolutionary. I was first\nintroduced to this concept of hot-reloadable C/C++ by \n\nCasey Muratori's Handmade Hero series\n, \nbut had held off on trying to implement the same workflow in Maya until\nnow. There are other resources on this topic, such as \n\nMolecular Matter's engine\n, \n\nDoug Binks/Matthew Jack's Runtime Compiled C/C++\n, \nand \n\nDanny Angelo Carminati Grein's \ncr.h\n header\n,\nall of which I referenced heavily while taking a look at this topic and\nimplementing a similar approach.\n\n\nSiew Yi Liang\n: I wrote this overly-long wall of text and the example code\nhere. You can find more of my ramblings \nhere\n.", 
            "title": "Credits"
        }, 
        {
            "location": "/credits/#credits", 
            "text": "This is neither a new idea, nor is it in any way revolutionary. I was first\nintroduced to this concept of hot-reloadable C/C++ by  Casey Muratori's Handmade Hero series , \nbut had held off on trying to implement the same workflow in Maya until\nnow. There are other resources on this topic, such as  Molecular Matter's engine ,  Doug Binks/Matthew Jack's Runtime Compiled C/C++ , \nand  Danny Angelo Carminati Grein's  cr.h  header ,\nall of which I referenced heavily while taking a look at this topic and\nimplementing a similar approach.  Siew Yi Liang : I wrote this overly-long wall of text and the example code\nhere. You can find more of my ramblings  here .", 
            "title": "Credits"
        }
    ]
}